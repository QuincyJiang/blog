
# 平时修改的项目，apk文件和代码分别推送到什么地方？
代码直接按照正常使用git的方式，在什么仓库克隆的，就推送到什么仓库，在什么分支开发，就推送到什么分支。也可以创建自己的dev分支，在功能完成之后合并到主分支。

编译出来的apk文件，一般是推送到以下几个仓库。
## 8953 移动招标 android 7.1.2
### aosp_new/android_vendor_cm

```
仓库地址：git@192.168.26.100:aosp_new/android_vendor_cm.git

当前开发的主分支： dev分支

```

拨号APP 放在 `apps/ipdmthj_cm/`
设置App 放在 `apps/CMSettings/`
状态栏SystemUI 放在 `apps/CMSystemUI/`

每次对应app有修改，编译完apk之后，放在对应目录，然后推送到远程仓库。

## 8909 南瑞3期 android 5.1 
### AOSP/android_vendor_telpo_prebuild_common


```
仓库地址：git@192.168.26.100:AOSP/android_vendor_telpo_prebuilt_common.git

当前开发的主分支： dev分支

```
该分支主要存放8909方案（android 5.1） 南瑞三期的一些通用的apk。

**注意，其中的`overide/launcher/TelpoLauncher3.apk `是8909平台和8953平台（当前正在开发的平台 android 7.1.2系统）通用的，如果日后修改了桌面 TelpoLauncher3.apk，请将apk推送到这个仓库下。**

### AOSP/android_vendor_telpo_resource
```
仓库地址：git@192.168.26.100:AOSP/android_vendor_telpo_prebuilt_resource.git

当前开发的主分支： dev分支

```
一般不会再修改了，只是存放一些多媒体展示文件。

### AOSP/android_vendor_telpo_prebuilt_voip

```
仓库地址：git@192.168.26.100:AOSP/android_vendor_telpo_prebuilt_voip.git


当前开发的主分支： dev分支

```
当需要修改南瑞版本的拨号软件时，需要将拨号软件编译为apk之后，放在
`overide/ipdmthj/ipdmthj_voip.apk` 路径下并推送到该远程仓库中。


# 如何使用gitlab账号推送代码

## 1.登录192.168.26.100 注册gitlab账号
## 2.在你的电脑上生成ssh 公钥私钥
具体步骤请查看链接 [创建ssh key 链接gitlab或github](https://blog.csdn.net/Troy__/article/details/40082657)
## 3.登录你的 gitlab账号
## 4.点击设置
![](/media/15344692885179.jpg)
## 5. 添加第一步中你生成的ssh公钥
![](/media/15344693290011.jpg)
将本地生成的rsa公钥粘贴在下方输入框中 就可以在你的电脑上推送代码了。
![](/media/15344693484016.jpg)

# 如何编译南瑞三期镜像包

## 一、链接到192.168.26.19服务器

可以通过ssh命令 或者securityCRT等软件进行登录
下面以ssh登录为例：

```
 ssh jiangxq@192.168.26.19
jiangxq@192.168.26.19's password:
```
在**password**输入密码 
```
jxq.123
```
此时命令行不会显示密码，直接回车就可以了。

当显示


```
Welcome to Ubuntu 16.04 LTS (GNU/Linux 4.4.0-93-generic x86_64)

 * Documentation:  https://help.ubuntu.com/

392 packages can be updated.
0 updates are security updates.

*** System restart required ***
Last login: Thu Aug 16 09:03:34 2018 from 192.168.1.152
```
表示登录成功。

## 二、切换到repo目录下编译镜像包

### 1. 进入8909的AOSP仓库

```
jiangxq@telpo-PowerEdge-R720:~$ cd /data/jiangxq/repo/msm8909/V101/
jiangxq@telpo-PowerEdge-R720:/data/jiangxq/repo/msm8909/V101$
```
查看一下当前AOSP的源码目录结构：

```
jiangxq@telpo-PowerEdge-R720:/data/jiangxq/repo/msm8909/V101$ ls
abi       build     developers   external    libcore          msm8909_emmc_img  pack.sh    system
art       build.sh  development  frameworks  libnativehelper  ndk               pdk        tools
bionic    cts       device       hardware    Makefile         out               prebuilts  vendor
bootable  dalvik    docs         kernel      mk.sh            packages          sdk        新建文本文档.txt
```


由于Android源码工程是一个代码量非常庞大的项目，上面显示的每一个模块都对应一个git仓库，如果每次同步代码要分别切换到对应模块目录下去**git pull** 就十分不便，为了应对这种问题，repo 应运而生。

repo只是一个同步代码的工具，是用来同步管理多个git仓库的。

关于repo的详细介绍，可以参考[这条连接](https://blog.csdn.net/nwpushuai/article/details/78778602)。

### 2. 同步代码

**首先执行 `source build/envsetup.sh`  为了将一些稍后可能会用到的便捷命令添加到终端。**
 
 
```java
jiangxq@telpo-PowerEdge-R720:/data/jiangxq/repo/msm8909/V101$ source build/envsetup.sh 
including device/qcom/common/vendorsetup.sh
including device/lge/mako/vendorsetup.sh
including device/telpo/TOS_IP/vendorsetup.sh
including device/telpo/common/vendorsetup.sh
including device/telpo/TOS/vendorsetup.sh
including device/generic/mini-emulator-mips/vendorsetup.sh
including device/generic/mini-emulator-x86_64/vendorsetup.sh
including device/generic/mini-emulator-arm64/vendorsetup.sh
including device/generic/mini-emulator-x86/vendorsetup.sh
including device/generic/mini-emulator-armv7-a-neon/vendorsetup.sh
including device/asus/fugu/vendorsetup.sh
including device/asus/grouper/vendorsetup.sh
including device/asus/tilapia/vendorsetup.sh
including device/asus/deb/vendorsetup.sh
including device/samsung/manta/vendorsetup.sh
including device/htc/flounder/vendorsetup.sh
including vendor/qcom/proprietary/common/vendorsetup.sh
including sdk/bash_completion/adb.bash
```

**其次 选择编译产品**

 `lunch 25`
选择编译产品 **TOS_IP user-debug**
 
```shell 
jiangxq@telpo-PowerEdge-R720:/data/jiangxq/repo/msm8909/V101$ lunch 25

============================================
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=5.1.1
TARGET_PRODUCT=TOS_IP
TARGET_BUILD_VARIANT=userdebug
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm
TARGET_ARCH_VARIANT=armv7-a-neon
TARGET_CPU_VARIANT=cortex-a7
TARGET_2ND_ARCH=
TARGET_2ND_ARCH_VARIANT=
TARGET_2ND_CPU_VARIANT=
HOST_ARCH=x86_64
HOST_OS=linux
HOST_OS_EXTRA=Linux-4.4.0-93-generic-x86_64-with-Ubuntu-16.04-xenial
HOST_BUILD_TYPE=release
BUILD_ID=LMY47V
OUT_DIR=out
============================================

```
 
 **最后执行 `repo sync` 命令，同步仓库代码。**


```shell
jiangxq@telpo-PowerEdge-R720:/data/jiangxq/repo/msm8909/V101$ repo sync
```

如果一切正常，表示当前仓库中的代码已经与远程仓库代码一致，并且本地没有暂未提交的修改。可以直接跳转到步骤3 进行编译。

如果有类似下面的提示：
![](/media/15344698833383.jpg)

表名你在对应的模块下还有一些尚未提交的修改。
有三个特殊仓库需要注意一下：

```
android_vendor_telpo_prebuilt_common
android_vendor_telpo_prebuilt_voip
android_vendor_telpo_prebuilt_resource
这三个仓库保存发布的apk文件和资源包，会导致仓库变得非常大；所以我们使用 git lfs 来管理apk大文件
```
如果sync出错的仓库是上面三个的其中之一
而且你没有手动做修改，请手动强制同步一下

```
jiangxq@telpo-PowerEdge-R720:/data/jiangxq/repo/msm8909/V101/vendor/telpo/prebuilt/common$ git reset --hard gitlab/dev
HEAD is now at 79bd701 update Telpo telphony ,adater pstn volume value

```
因为此时只是将git与远端仓库保持同步了，但是仓库是用git lfs托管的，此时真正的文件还没有下载下来，要使用 **git lfs pull** 拉取真正的文件。


```
jiangxq@telpo-PowerEdge-R720:/data/jiangxq/repo/msm8909/V101/vendor/telpo/prebuilt/common$ git lfs pull
Git LFS: (2 of 2 files) 13.17 MB / 13.17 MB                                               
```

### 3. 编译镜像包
#### 编译新硬件镜像包：
进入
`vendor/qcom/properity/`
目录下，使用 `git checkout nari` 切换到**nari**分支 同时`git pull gitlab nari` 同步一下远端nari分支代码 
#### 编译旧硬件镜像包：
进入
`vendor/qcom/properity/`
目录下，使用 `git checkout v101` 切换到**v101**分支 同时`git pull gitlab V101` 同步一下远端`V101`（注意 **远程仓库的V是大写**）分支代码

进行完切换分支的操作之后，
使用croot命令 跳转回源码的根目录
然后使用 `make -j32` 开启32线程编译系统镜像


```
jiangxq@telpo-PowerEdge-R720:/data/jiangxq/repo/msm8909/V101/vendor/telpo/prebuilt/common$ croot
jiangxq@telpo-PowerEdge-R720:/data/jiangxq/repo/msm8909/V101$ make -j32

```

### 4. 打包镜像包

进入 `/data/jiangxq/buildScript/ ` 目录

执行 `python buildScript.py `

```
jiangxq@telpo-PowerEdge-R720:/data/jiangxq/buildScript$ python buildScript.py 
```

### 5.发布镜像包
进行完第四步之后，打包完成的镜像包在

```
//192.168.26.19/public_share/project/TOS_IP/DailyBuild/201808**/

```
# OTA升级模块

## 一、仓库和分支说明

```java
仓库地址： http://192.168.26.100/JiangXiaQiu/OTA
分支说明： 主分支 apk_update
```

## 二、设计架构

主框架使用MVP模式开发，网络请求使用`Retrofit`+`RxJava`,使用`Dagger2`作为依赖注入，使用`FileDownloader`多线程下载器作为主要的下载框架。

### 1. M 层
对应网络请求和返回结果 由json序列化的JavaBean实例
### 2. P层 & View 层
包括应用升级界面和 系统更新界面
#### ApkUpdatePresenter

**接口：**

```java
   public interface Presenter{
      void getApkList(int page);
      boolean checkNetwork();
      void checkAvailable(int page);
      List<ApkUpdateItemBean> checkLocalApkCanUpdateOrNot(List<AppList> app);
      void onViewDestroy();
   }
```

#### ApkUpdateFragment
**接口：**

```java
 public interface View{
      void refreshUi(List<ApkUpdateItemBean> apks);
      void showNetWorkNotAvailable();
      void showNoUpdate();
      void showApkListView();
   }
```
 
**流程图：**

![Artboard 8](/media/Artboard%208.png)

#### SystemUpdatePresenter
**接口：**

```java
 public interface Presenter{
       void checkUpdateAvailable();
       void downloadOTAPackage();
       void checkAvailable();
       boolean checkStorage();
       boolean checkNetwork();
       boolean checkBattery();
       void onViewDestroy();
       int getStatus();
       void resumeDownload();
       void pauseDownload();
   }
```
#### SystemUpdateFragment
**接口**

```java
 public interface View{
       void showNoUpdate();
       void showDownloading(int percent);
       void showDownloadFinish();
       void showDownloadFail(String msg);
       void showUpdateAvailable();
       void showUpdateSuccess();
       void showUpdateFailed();
       void showNetWorkNotAvailable();
       void showStorageNotAvailable();
       void showBatteryNotAvailable();
       void  showLocalPkgAvailable();
       void showViewByStatus(int status);
       void showWaitingToReboot();
       void showCheckingUpdate();
       void showCheckingMD5();
       void showForceUpdateDialog();
   }
```

**流程图：**

##### 1. 手动点击检查更新时

![Artboard 7](/media/Artboard%207.png)



##### 2. 进入首页获取app升级状态

![Artboard 6](/media/Artboard%206.png)

# 拨号软件 会议和视频模块

## 一、仓库和分支说明
```
仓库地址：
http://192.168.26.100/telpo/ipdmthj-new
分支说明：
voip_android_N 当前7.1.2系统上正在开发迭代的主分支
nari_master 南瑞3.0主分支

```
## 二、会议模块
### 包结构：
#### 页面相关：

```java
// 暂时无用
app/src/main/java/com/telpo/conference/activity/ConferenceActivity.java
// 创建会议的activity ①
app/src/main/java/com/telpo/conference/activity/CreateConfActivity.java
// 会议主页面 包含会议列表页 会议详情页 ②
app/src/main/java/com/telpo/conference/activity/MainConfActivity.java
//adapter 
app/src/main/java/com/telpo/conference/adapter
// 视频页面fragment 镶嵌在callActivity中 ③
app/src/main/java/com/telpo/conference/fragment/callVideoFragment.java
// 暂时无用
app/src/main/java/com/telpo/conference/fragment/ConfAgendaFragment.java
// 会议详情fragment ④
app/src/main/java/com/telpo/conference/fragment/ConfDetailFragment.java
// 会议列表fragment 包含下面的列表 和上面切换栏 ⑤
app/src/main/java/com/telpo/conference/fragment/ConfListFragment.java
// 各会议列表fragment 镶嵌在ConfListFragment下面 ⑥
app/src/main/java/com/telpo/conference/fragment/ConfListFragmentStub/
// 会议主页面 镶嵌在MainConfActivity中 ⑦
app/src/main/java/com/telpo/conference/fragment/ConfMainFragment.java
// 暂时无用
app/src/main/java/com/telpo/conference/fragment/ConfMemberFragment.java
```
![-w1177](/media/15343011281342.jpg)

![-w1166](/media/15343011866705.jpg)

#### 逻辑相关
与加载逻辑相关的代码 都在`cloudvideoconference`模块中
模块采用MVP 结构设计

![](/media/15343017167489.jpg)

以获取会议详情页为例：
##### Model层
Model层只负责获取数据

**ConfDetailModel.java**

```java

public class ConfDetailsModel extends BaseModel<QueryConfInfoResultBean> {

// 获取会议详情数据 包装为subscription返回
    public Subscription getInfoDetails(QueryInfoRequestBean requestBean, Observer<QueryConfInfoResultBean> result){
        Observable<QueryConfInfoResultBean> observable = ApiService.getInstance()
                .queryConferenceInfo(Utils.generateHeaderMap(QUERY_CONF),requestBean);
        return subscribe(observable,result);
    }
    
    // 将observable 与observer关联起来 返回一个订阅者 
    @Override
    public Subscription subscribe(Observable<QueryConfInfoResultBean> mObservable, Observer<QueryConfInfoResultBean> observer) {
        return mObservable.subscribeOn(Schedulers.io())
                .map(new Func1<QueryConfInfoResultBean, QueryConfInfoResultBean>() {
                    @Override
                    public QueryConfInfoResultBean call(QueryConfInfoResultBean queryResultBean) {
                    // 判断服务器返回码 如果不是200 且不为0 就抛出ServerException 让P层去捕获并处理
                        if(queryResultBean.getIResult()!=200&&queryResultBean.getIResult()!=0){
                            throw new ServerException(queryResultBean.getIResult());}
                            if(queryResultBean != null){
                                QueryConfInfoResultBean.ConfInfoBean.SqMemberListBean sqMemberList = queryResultBean.getConfInfo().getSqMemberList();
                                if(sqMemberList != null && sqMemberList.getItem() != null && sqMemberList.getItem().size()>0){
                                    for(QueryConfInfoResultBean.ConfInfoBean.SqMemberListBean.ItemBean itemBean:sqMemberList.getItem()){
                                        ContactsMember contactsMember = ContactUtils.findContactByPhone(itemBean.getStrName());
                                        itemBean.setContactId(contactsMember.getId());
                                        itemBean.setContactName(contactsMember.getName());
                                    }
                                }
                            }
                        return queryResultBean;
                    }
                })
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(observer);
    }
}

```
##### P层
**ConferenceDetailsContract.java**

```java
public interface BaseView {
    void showLoading();
    void dissmissLoading();
    void showToast(String msg);
    void showToast(int resId);
}

public class ConfDetailsContract {
//view接口规定了会议详情的fragment需要实现的视图 view不管具体业务 只负责展示

    public interface View extends BaseView{
        void showErrorPage();
        void showErrorToast(String msg);
        void showDetailsView(QueryConfInfoResultBean confInfo);
    }
    // presenter接口 规定presenter需要实现的业务逻辑 
    public interface Presenter{
        void getConfDetails(QueryInfoRequestBean request);
    }
}
```

**ConfDetailsPresenter.java**

```java
public class ConfDetailsPresenter extends BasePresenter<ConfDetailsContract.View> implements ConfDetailsContract.Presenter {

    private ConfDetailsModel detailsModel;
    public ConfDetailsPresenter(ConfDetailsContract.View mvpView) {
        super(mvpView);
        detailsModel = new ConfDetailsModel();
    }
    
// p层负责链接M层和View层 获取数据 并根据相应的结果去操作view 显示对应的状态
    @Override
    public void getConfDetails(QueryInfoRequestBean request) {
    // 通过Model去拿数据 返回subscription
        mvpView.showLoading();
        Subscription subscription = detailsModel.getInfoDetails(request, new Observer<QueryConfInfoResultBean>() {
            @Override
            public void onCompleted() {
                mvpView.dissmissLoading();
            }


// onError回调中 判断是不是上面Model层抛出的ServerException
// 如果是 就去捕获并根据业务处理
            @Override
            public void onError(Throwable e) {
                mvpView.dissmissLoading();
                if(e instanceof ServerException){
                    processErrorCode(Integer.parseInt(e.getMessage()));
                    return;
                }
                mvpView.showErrorPage();
                mvpView.showErrorToast(e.getMessage());
            }
// onNext中 拿到网络请求的数据 操作对应view去显示相关数据
            @Override
            public void onNext(QueryConfInfoResultBean queryConfInfoResultBean) {
                mvpView.dissmissLoading();
                mvpView.showDetailsView(queryConfInfoResultBean);
            }
        });
        addSubscribe(subscription);
    }
    
    // 处理返回码
    @Override
    protected void processErrorCode(int code) {
        if(code == CODE_401.getCode()){
            mvpView.showErrorToast(CODE_401.getMsg());
            mvpView.showErrorPage();
        }else if(code == CODE_499.getCode()){
            mvpView.showErrorToast(CODE_499.getMsg());
            mvpView.showErrorPage();
        }else if(code == CODE_998.getCode()){
            mvpView.showErrorToast(CODE_998.getMsg());
            mvpView.showErrorPage();
        }
        else if(code == CODE_999.getCode()){
            mvpView.showErrorToast(CODE_999.getMsg());
            mvpView.showErrorPage();
        }
    }
}
```

##### View层

```java
public class ConfDetailFragment extends BaseFragment<ConfDetailsPresenter> implements ConfDetailsContract.View, View.OnClickListener,ConfControlContract.View {
    ···
    @Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.iv_conf_edit:
            // 去到创建会议界面
                toCreateConfView();
                break;
                // 打开选人窗口 添加会议成员
            case R.id.tv_conf_add_members:
                ···
=               break;
        }
    }
    
    // 跳转到创建会议界面
    private void toCreateConfView(){
    // 先判断当前会控id 会控密码是否存在 不存在就跳转到设置页去配置会控参数
        if(CONFERENCE_CONTROL_ACCOUNT.USER_ID().equals("")||CONFERENCE_CONTROL_ACCOUNT.PASSWORD().equals("")) {
            ConfirmDialog dialog = new ConfirmDialog(getActivity(), position -> {
                if (position == 1) {
                    try {
                        Intent intent = new Intent("telpo.intent.action.SETTINGSACTIVITY");
                        startActivity(intent);
                    } catch (ActivityNotFoundException e) {
                        e.printStackTrace();
                    }
                }
            }).setTitle(getString(R.string.no_account_detected_title));
            dialog.setContent(getString(R.string.no_account_detected_content));
            dialog.show();
        }else{
        // 存在 就把会议详情信息当做携带的参数转发到会议详情页 
            Intent intent = new Intent(getActivity(),CreateConfActivity.class);
            info = new ConfDetailsInfoParceable();
            info.setConfHost(infoResult==null?"":infoResult.getConfInfo().getStrConvener().getValue());
            info.setConfTheme(infoResult==null?"":infoResult.getConfInfo().getStrSubject());
            info.setVideo(infoResult!=null&&infoResult.getConfInfo().getStConferneceType().isBHDVideo());
            addMembersToInfo();
            intent.putExtra(CONF_DETAILS,info);
            getActivity().startActivity(intent);
        }
    }

// 把与会成员添加到会议成员列表中 当做携带的参数转发到创建会议里
    private void addMembersToInfo(){
    ···
    }

    @Override
    public void showLoading() {
        refreshLayout.setRefreshing(true);
    }

    @Override
    public void dissmissLoading() {
        if(refreshLayout.isRefreshing()){
            refreshLayout.setRefreshing(false);
        }
    }


    @Override
    public void showToast(String msg) {
        RxToast.text(TelpoApp.getContext(), msg);
    }

    @Override
    public void showErrorPage() {
        if(refreshLayout.isRefreshing()){
            refreshLayout.setRefreshing(false);
        }
        refreshLayout.setVisibility(View.GONE);
        icNoConf.setVisibility(View.VISIBLE);
    }

    @Override
    public void onResume() {
        super.onResume();
        refreshLayout.setRefreshing(true);
        loadData();
        EventBus.getDefault().register(this);
    }

    @Override
    public void onPause() {
        super.onPause();
        EventBus.getDefault().unregister(this);
    }

    @Override
    public void showErrorToast(String msg) {
        //RxToast.error(getActivity(),msg);
    }


// presenter加载成功后会回调该方法
    @Override
    public void showDetailsView(QueryConfInfoResultBean confInfo) {
        icNoConf.setVisibility(View.GONE);
        refreshLayout.setVisibility(View.VISIBLE);

        this.infoResult = confInfo;

        if(refreshLayout.isRefreshing()){
            refreshLayout.setRefreshing(false);
        }

        mConfTheme.setText(confInfo.getConfInfo().getStrSubject());
        mConfHost.setText(confInfo.getConfInfo().getStrConvener().getValue());
        mConfType.setText(confInfo.getConfInfo().getStConferneceType().isBHDVideo()?getString(R.string.conf_meeting_type_video):getString(R.string.conf_meeting_type_audio));
//        mConfStartTime.setText(confInfo.getConfInfo().getStrBeginTime()+"-"+confInfo.getConfInfo().getStrEndTime());
        mConfStartTime.setText(processTimeStr(confInfo.getConfInfo().getStrBeginTime(),confInfo.getConfInfo().getStrEndTime()));

        members.clear();
        members.addAll(confInfo.getConfInfo().getSqMemberList().getItem());
        adapter.updateAll(members);

        this.confInfo = confInfo.getConfInfo();

        mConfPwd.setText(String.format(getResources().getString(R.string.conf_pwd),confInfo.getConfInfo().getStPassword().getStrParticipant()));
        mConfNum.setText(String.format(getResources().getString(R.string.conf_num),confInfo.getConfInfo().getStrConfID().getValue()));

        refreshConfControl();


    }

    private void refreshConfControl(){

        if(confInfo.getConfState() == 2 && Utils.isControlHost(confInfo,requestBean.getStrUserId())){
            //会议正在召开,且是主持人才能进行会控
            mConfCOntrol.setVisibility(View.VISIBLE);
            controlRecycler.setVisibility(View.VISIBLE);
            controlMemberRecycler.setVisibility(View.VISIBLE);
            mConfMemberList.setVisibility(View.GONE);
            addMembers.setVisibility(View.VISIBLE);
            mConfEdit.setVisibility(View.INVISIBLE);

            mConfControlPresener.getConfOptionList();
            mConfControlPresener.queryConferenceMembers(confInfo.getStrConfID().getValue());

        }else{
            endConference();
        }

    }

    @NonNull
    @Override
    protected View creatRootView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(R.layout.conf_fragment_conf_details,null);
    }

    @Override
    protected void initToolBar() {

    }
    @NonNull
    @Override
    protected ConfDetailsPresenter initPresenter() {
        mConfControlPresener = new ConfControlPresener(this);
        return new ConfDetailsPresenter(this);
    }

    @Override
    protected void initView() {
        ···
        refreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
            @Override
            public void onRefresh() {
                mPresenter.getConfDetails(requestBean);
            }
        });
        mConfMemberList.setLayoutManager(new LinearLayoutManager(getContext()));

        adapter = new ConfDetailsMemberListAdapter(getActivity());
        adapter.setOnItemLongClickListener(new ConfDetailsMemberListAdapter.OnItemLongClickListener() {
            @Override
            public void onItemLongClick(int position, String title) {
                if(members!=null)
                    toMoreInfoView(members.get(position));
            }
        });
        mConfMemberList.setAdapter(adapter);

        controlRecycler = $(R.id.rv_member_options);
        controlRecycler.setLayoutManager(new GridLayoutManager(getActivity(),4));
        mConfOptionAdapter = new ConfOptionAdapter(getActivity());
        controlRecycler.setAdapter(mConfOptionAdapter);

        mConfOptionAdapter.setOnItemClickListener(new BaseRecyclerViewAdapter.OnItemClickListener<ConfOptionEntity>() {
            @Override
            public void onClick(View v, int position) {
                switch (position) {
                    case 0:
                        showDelayDialog();
                        break;
                    case 1:
                        showConfModeDialog();
                        break;
                    case 2:
                        mConfControlPresener.endConference("");
                        break;
                    case 3:
                        mConfControlPresener.setSlient();
                        break;
                }

            }
            @Override
            public void onClick(View v, ConfOptionEntity entity) {

            }
        });

    }

    @Override
    protected void initData() {

    }

//  调用presenter去获取数据
    @Override
    protected void loadData() {
        if(TextUtils.isEmpty(requestBean.getStrConfID())){
            showErrorPage();
            return;
        }
        mPresenter.getConfDetails(requestBean);
    }

    @Override
    protected void fragmentDestroy() {
    }

    public void refreshData(String uid, String confID){
        requestBean.setStrConfID(confID);
        if(TextUtils.isEmpty(confID)){
            showErrorPage();
            return;
        }
        requestBean.setStrUserId(uid);
        requestBean.setStrConfID(confID);
        requestBean.setICycleNo(0);
        mConfControlPresener.loadConfControl(uid,confID);
        loadData();
    }

    //// TODO: 2018/5/16 跳转到会议成员详情页面
    private void toMoreInfoView(QueryConfInfoResultBean.ConfInfoBean.SqMemberListBean.ItemBean member){}


    private void showDelayDialog(){
        if(delayDialog != null && delayDialog.isVisible()){
            return;
        }
        final int[] times = getResources().getIntArray(R.array.conference_delay_time_array);
        delayDialog = BaseMenuFragment.newInstance(getResources().getStringArray(R.array.conference_delay_array)
                , getResources().getString(R.string.conference_menu_proconference));
        delayDialog.setOnItemClickListener(new BaseMenuFragment.OnItemClickListener() {
            @Override
            public void onItemClick(int position) {
                mConfControlPresener.prolongConference(times[position]);
            }
        });
        delayDialog.show(getActivity().getFragmentManager(),"delay");
    }

    private void showConfModeDialog(){
        if(modeSwitchDialog != null && modeSwitchDialog.isVisible()){
            return;
        }
        modeSwitchDialog = new ConfModeSwitchDialog();
        modeSwitchDialog.setSwitchLayoutListener(new ConfModeSwitchDialog.SwitchLayoutListener() {
            @Override
            public void switchListener(String mediaType,int count) {
                mConfControlPresener.switchConferenceMode(mediaType,count);
            }
        });
        modeSwitchDialog.show(getActivity().getFragmentManager(),"mode");
    }

    @Override
    public void endConference() {
        mConfCOntrol.setVisibility(View.GONE);
        controlRecycler.setVisibility(View.GONE);
        controlMemberRecycler.setVisibility(View.GONE);
        addMembers.setVisibility(View.INVISIBLE);

        mConfEdit.setVisibility(View.VISIBLE);
        mConfMemberList.setVisibility(View.VISIBLE);

    }

    @Override
    public void updateOptionList(List<ConfOptionEntity> entities) {
        mConfOptionAdapter.updateAll(entities);
    }

    @Override
    public void showToast(int strId) {
        RxToast.text(getActivity(),strId);
    }

    @Override
    public void updateMemberList(List<SubscriberBean> members) {
        initConfControl();
        confMemberAdapter.updateAll(members);
        subscriberBeans = members;
    }
    public void initConfControl(){
        if(confMemberAdapter == null){
            confMemberAdapter = new ConfMemberAdapter(getActivity());
            controlMemberRecycler.setLayoutManager(new LinearLayoutManager(getActivity()));
            controlMemberRecycler.setAdapter(confMemberAdapter);
            confMemberAdapter.setMembersCallBack(new ConfMemberAdapter.ConfMembersCallBack() {
                @Override
                public void removeMembers(SubscriberBean subscriberBean) {
                    //移除添加成员
                    mConfControlPresener.removeMember(subscriberBean);
                }

                @Override
                public void reAddMembers(SubscriberBean subscriberBean) {
                    mConfControlPresener.reInvateMember(subscriberBean);
                }

                @Override
                public void closeMemberVoice(SubscriberBean subscriberBean) {
                    //静音
                    mConfControlPresener.closeMemberVoice(subscriberBean);

                }

                @Override
                public void setMemberMute(SubscriberBean subscriberBean) {
                    //成员闭音
                    mConfControlPresener.setMembersMute(subscriberBean);
                }

            });
        }


    }
    //  处理消息
    @Subscribe(threadMode = ThreadMode.MAIN)
    public void onEventMainThread(ConfDestoryedEvent event){
        Log.d(TAG, "onEventMainThread: ");
        if(confInfo == null) return;
        if(!confInfo.getStrConfID().getValue().equals(event.confId)){
            return;
        }
        if(event.destoryed){
            //会议结束
            endConference();
         //   loadData();
            return;
        }
        mConfControlPresener.queryConferenceMembers(event.confId);
        mConfControlPresener.getConfOptionList();
        //刷新页面
        loadData();

    }

    private String processTimeStr(String start,String end){
        if(start!=null&&end!=null){
            String year = start.split(" ")[0];
            String startTime = start.split(" ")[1];
            String endTime = end.split(" ")[1];
            return year+" "+startTime+"-"+endTime;
        }
        return "";
    }
}

```


## 三、视频模块
主要涉及到
**CallVideoFragment.java**
**WebrtcHelper.java**
**linphonelibraty-v101**模块中的**org/webrtc/**模块

#### 1. CallVideoFragment.java
视屏界面fragment
负责初始化webrtc，初始化渲染TextureView，开启、关闭辅流 主流的发送与接收，开启、关闭双屏异显，切换视屏预览的布局，暂停和恢复webrtc，关闭webrtc，释放相关资源。


```java

/**
 * 视频通话界面 流程务必遵守 ↓↓↓↓
 * TextureView 初始化完毕（onSurfaceTextureAvailable（）回调执行) --> WebrtcHelper.init(int index) --> WebRTCHelper.webrtc_startReceive/Send(int index)
 * 双流视频的发送接收是独立开始的
 * webrtc_startReceive（int index） 开始接收 参数为主流 0  辅流 1
 * webrtc_startSend（int index） 开始发送 参数为主流0 辅流 1
 * 两个方法也必须等到textureView 初始化完毕才可以执行
 * 暂停辅流发送 stopSendOnly(1)
 * 恢复辅流发送 startSendOnly(1) 这两个方法不依赖TextureView的状态
 * 暂停辅流接收 stopReceiveOnly(1)
 * 恢复辅流接收 startReceiveOnly(1) 双屏异显的时候 因为MediaEngine的渲染对象更改了 所以当第二屏销毁的时候 本端重新显示辅流画面需要重新设置setRemoteView();
 */
public class CallVideoFragment extends Fragment {
    private static final String TAG = "CallVideoFragment";
    private boolean mCaptureVisible = true; // 主流本端窗口是否可见
    private BroadcastReceiver incomingVideoSizeReceiver; // 接收到对端视频流之后 下层通知上层视频尺寸的广播
    public double screenW = TelpoApp.IS_LARGE_TABLET?1040:800; //主窗口宽高 横屏设备1040*800 竖屏 800*1280
    public double screenH = TelpoApp.IS_LARGE_TABLET?800:1280;
    public double localSetHeight = screenH; //本端采集视频的宽高 分辨率设置为vga 720p 1080p 屏幕的宽高比是不一样的
    public double localSetWidth = screenW;
    public double setWidth = screenW; // 收到对端视频宽高 根据设备的显示框大小进行相应比例缩放后设置给该值
    public double setHeight =screenH;
    private int receivedHeight =(int)screenH; // 广播里收到的对端视频的宽高
    private int receivedWidth = (int) screenW;
    private boolean isFullScreen = false; //记录当前主视频窗口里是不是全屏状态
    private AndroidVideoWindowImpl androidVideoWindowImpl;
    private CallActivity inCallActivity;
    private TextView videoInfo; // 视频参数小窗口
    private ScaleLinearLayout llRemoteSurface;// 对端主流 本端主流 对端辅流 本端辅流 TextureView 的承载窗口（可以缩放的linearLayout）
    private ScaleLinearLayout llLocalSurface;
    private ScaleLinearLayout llLocalSurfaceSub;
    private ScaleLinearLayout llRemoteSurfaceSub;
    private TextureView mLocalTextureView;// 本端主流TextureView
    private ScaledTextureView mRemoteTextureView;// 远端主流TextureView，可以缩放，layoutGravity在llRemoteSurface的中间，所以主流窗口缩放的时候可以始终保持在父view的中间
    private TextureView mLocalTextureViewSub;// 本端辅流TextureView
    private TextureView mRemoteTextureViewSub;// 远端辅流TextureView
    private ImageView info;// 显示视频信息的icon
    private LinphoneCall currentCall;
    private ViewState currentViewState = ViewState.REMOTE_MAIN; // 当前的视图状态
    private ImageView mFullScreen, mChangeViewMode,mSendSubStream,mDualDisplay;
    private View line;// 右侧的分割线
    private float firstDragH = 0f;// 记录下首次点击事件的 宽高值
    private float firstDragW = 0f;
    private LinearLayout mIconContainer;
    private Handler mHandler;
    public static final String INTENT_HDMI = "com.telpo.hdmi";// hdmi插拔广播 暂未启用
    public static final String INTENT_INCOMING_VIDEO_SIZE = "incomingvideosize";// 底层上报给上层的视频尺寸广播
    private SecondSubRemoteDisplayView mSecondDisplay; // 双屏异显 显示辅流对端
    private SecondSubLocalDisplayView mSecondLocalDisplay; // 双屏异显 显示辅流本端
    private Boolean isHDMIAvailable = HDMI_STATUS;
    private DualDisplayState currentDualDisplayState = DualDisplayState.NORMAL; // 当前双屏异显状态
    private SendSubStreamState currentSendSubStreamState = SendSubStreamState.NORMAL;// 当前发送辅流状态
    // 记录辅流本端TextureView是否创建完成 因为辅流要做动态收发，就是一开始不发送辅流（设置辅流view不可见，就不会初始化辅流通道），
    // 当第一次需要发送的时候 将view设置为可见就可以发送了，此时webrtc 辅流通道才完成初始化过程，就要用个标志位标记该状态，
    // 在本次通话没结束的过程中点击暂停发送和恢复发送的时候，可以根据这个标志位判断，如果为true，就不用重新初始化webrtc通道，直接调用暂停发送和恢复发送接口
    private Boolean isLocalSubViewAvailable = false;
    //视图状态 分别为 主流本端 主流对端 辅流本端 双屏对端 双屏本端 本端主流 无辅流且主流优先 无辅流且辅流优先
    public  enum ViewState {
        LOCAL_MAIN, REMOTE_MAIN, REMOTE_SUB, DUAL_DISPLAY_REMOTE, DUAL_DISPLAY_LOCAL, LOCAL_SUB, ONE_STREAM_REMOTE, ONE_STREAM_LOCAL
    }
    //双屏异显状态 分别为 第二屏显示辅流对端 显示辅流本端 退出双屏异显状态
    public enum DualDisplayState {
        REMOTE,LOCAL,NORMAL
    }
    //辅流发送状态 分别为 正在发送 正在请求发送  未发送
    public enum SendSubStreamState{
        SENDING,REQUEST,NORMAL
    }
    private ConfirmDialog mRequestSendDialog;// 请求发送辅流对话框
    private ConfirmDialog mDualDisplayDialog;// 双屏异显对话框
    ···
    
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        LogUtil.v(TAG,"onCreateView");
        
        ···  
              // 设置中是否开启显示视频参数选项
       if(SettingUtils.getInstance().getShowVideoInfo()){
            info.setVisibility(View.VISIBLE);
        }else {
            info.setVisibility(GONE);
            videoInfo.setVisibility(GONE);
        }
        // 初始化各布局参数
        initLayoutParms();
        initVideoWidthInfo();
        doRefreshInfo();
        initView();
        initListener();
        initTextureView(view);
        return view;
    }

    private void initLayoutParms(){
         localParams = (RelativeLayout.LayoutParams)llLocalSurface.getLayoutParams();
         remoteParams = (RelativeLayout.LayoutParams)llRemoteSurface.getLayoutParams();
         remoteSubParams = (RelativeLayout.LayoutParams)llRemoteSurfaceSub.getLayoutParams();
         localSubParms = (RelativeLayout.LayoutParams)llLocalSurfaceSub.getLayoutParams();
         textureRemoteParms = mRemoteTextureView.getLayoutParams();
         textureLocalParms = mLocalTextureView.getLayoutParams();
         textureLocalSubParms = mLocalTextureViewSub.getLayoutParams();
         textureRemoteSubParms = mRemoteTextureViewSub.getLayoutParams();
    }
    /**
     * 需求要求只有单流的时候 视频界面为 主流铺满 辅流右下角小框 且主流在辅流之下 不要显示分割线
     * 所以只有单流的时候 主视图窗口的宽就改为1280了 有双流 主视图窗口宽改成1040为了给分割线右边的区域留下显示空间
     * 当采集分辨率设置为720p时  视频宽高比为16:9(1280*720)为了防止视频变形要修改下采集视频的窗口size
     * */
    private void initVideoWidthInfo(){
        String size = "";
        if(LinphoneManager.getLcIfManagerNotDestroyedOrNull()!=null){
            size = LinphoneManager.getLcIfManagerNotDestroyedOrNull().getConfig().getString(
                    "video", "size", "vga");
        }
        if(IPCallHelper.isSubStreamEnable(currentCall)){
            screenW = 1040;
            if(size.equals("720p")||size.equals("1080p")) {
                localSetHeight = 585;
                localSetWidth = 1040;
            }
        }else {
            screenW = 1280;
            if(size.equals("720p")||size.equals("1080p")) {
                localSetHeight = 720;
                localSetWidth = 1280;
            }
        }
        LogUtil.v(TAG,"initVideoWidth"+"screenW:"+screenW+"localSetHeight:"+localSetHeight+"localSetWidth"+localSetWidth);
    }

    /**
     * 如果一开始呼叫就有辅流参数 直接显示远端辅流窗口（默认是开启接收辅流的 如果对端不发 就是黑屏 对端发了 就可以直接显示出来）
     * 本端辅流窗口先不显示 因为辅流并不是视频一创建就发送的 而是点击申请发送后 对端允许了才开始发送
     * 因为辅流发送通道的初始化是在TextureView 的available回调中做的，textureview不显示 就不会回调初始化方法
     * 所以本端辅流的发送窗口默认隐藏 当点击发送时 设置为可见 就会回调Texture的回调方法 从而初始化通道去发送辅流
     * */
    private void initView(){

        if(IPCallHelper.isSubStreamEnable(currentCall)){
            mSendSubStream.setVisibility(View.VISIBLE);
            mDualDisplay.setVisibility(View.VISIBLE);
            llRemoteSurfaceSub.setVisibility(View.VISIBLE);
            mRemoteTextureViewSub.setVisibility(View.VISIBLE);
        }else{
            mSendSubStream.setVisibility(GONE);
            mDualDisplay.setVisibility(GONE);
            llRemoteSurfaceSub.setVisibility(GONE);
            llLocalSurfaceSub.setVisibility(GONE);
            line.setVisibility(GONE);
            setViewMode(ViewState.ONE_STREAM_REMOTE);
        }
        LogUtil.v(TAG,"isSubStreamEnable?"+IPCallHelper.isSubStreamEnable(currentCall));
    }
    /**
     * 初始化TextureView窗口
     * webrtc 引擎必须等到TextureView available之后才能初始化
     * */
    private void initTextureView(View view){
        // 初始化主流发送窗口
        mLocalTextureView.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() {
            @Override
            public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
                LogUtil.d(TAG,"mLocalTextureView onSurfaceTextureAvailable");
                WebRTCHelper.setLocalTextureView(0, mLocalTextureView);
                WebRTCHelper.webrtc_init(0,currentCall);
                WebRTCHelper.webrtc_startSend(0);
            }
            
            ···
        });
        
        // 初始化主流接收窗口
        mRemoteTextureView.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() {
            @Override
            public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
                LogUtil.d(TAG,"mRemoteTextureView onSurfaceTextureAvailable");
                WebRTCHelper.setRemoteTextureView(0, mRemoteTextureView);
                WebRTCHelper.webrtc_init(0,currentCall);
                WebRTCHelper.webrtc_startReceive(0);
            }
            
            ···   
             });
        // 初始化辅流发送窗口
        mLocalTextureViewSub.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() {
            @Override
            public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
                LogUtil.d(TAG,"mLocalTextureViewSub onSurfaceTextureAvailable");
                isLocalSubViewAvailable = true;
                WebRTCHelper.setLocalTextureView(1, mLocalTextureViewSub);
                WebRTCHelper.webrtc_init(1,currentCall);
                WebRTCHelper.webrtc_startSend(1);
            }

          ···
          
                  });
        // 初始化辅流接收窗口
        mRemoteTextureViewSub.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() {
            @Override
            public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
                LogUtil.d(TAG,"mRemoteTextureViewSub onSurfaceTextureAvailable");
                WebRTCHelper.setRemoteTextureView(1, mRemoteTextureViewSub);
                WebRTCHelper.webrtc_init(1,currentCall);
                WebRTCHelper.webrtc_startReceive(1);
            }
            ···
            
                    });
    }
    
    // 请求发送辅流对话框 点击确认就去申请发送辅流
    private void showSendRequestDialog() {
        ConfirmDialog dialog = new ConfirmDialog(getActivity(), position -> {
            if (position == 1) {
                requestSendSubStream();
            }
        }).setTitle(getString(R.string.conf_start_to_send_sub_stream_title));
        dialog.setContent(getString(R.string.conf_detect_hdmi_plugged_in));
        dialog.show();
    }
    
    // 双屏异显对话框 点击确认就开启双屏异显
    private void showDualDisplayDialog(){
        if(mDualDisplayDialog == null){
            mDualDisplayDialog = new ConfirmDialog(getActivity(),
                    new ConfirmDialog.ConfirmDialogBuilder()
                            .style(ConfirmDialog.DialogStyle.THREE)
                            .button2(getString(R.string.conf_dual_display_remote))
                            .button3(getString(R.string.conf_dual_display_local))
                            .callback(position ->{
                                        if(position == 1){
                                            showSecondRemoteScreen();
                                        }
                                        else if(position == 2){
                                            if(WebRTCHelper.isStreamSending(1))
                                            showSecondLocalScreen();
                                            else RxToast.warning(getActivity(),getString(R.string.conf_sub_stream_has_not_been_init));
                                        }
                                    }
                            ).build())
                    .setTitle(getString(R.string.conf_enable_dual_display_title))
                    .setContent(getString(R.string.conf_enable_dual_display));
        }
        mDualDisplayDialog.show();
    }
    private void showSendSubStreamDialog(){
        if(mRequestSendDialog == null){
            mRequestSendDialog = new ConfirmDialog(getActivity(), position -> {
                if (position == 1) {
//                    if(IPCallHelper.isInConference(currentCall))
                    requestSendSubStream();
//                    else
//                        startSendSubStream();
                }
            }).setTitle(getString(R.string.conf_start_to_send_sub_stream_title));
            mRequestSendDialog.setContent(getString(R.string.conf_start_to_send_sub_stream));
        }
        mRequestSendDialog.show();
    }
    /**
     * 请求发送辅流 当协商成功之后 CallActivity中会回调startSendSubStream（）方法
     * */
    public void requestSendSubStream(){
        if(currentDualDisplayState==DualDisplayState.NORMAL){
        currentSendSubStreamState = SendSubStreamState.REQUEST;
        RxToast.success(getActivity(),R.string.conf_starting_sub_stream);
        setSendSubStreamIconClickStatus(false);
        LinphoneManager.getLc().bfcpFloorRequestSend();
        LogUtil.d(TAG,"request send sub stream");}
        else {
            LogUtil.d(TAG,"start send sub stream, currentDualDisplayState:"+currentDualDisplayState);
            RxToast.warning(getActivity(),R.string.conf_quit_dual_display_warning);
        }
    }

    /**
     * 请求发送辅流被对端拒绝
     * */
    public void showRequestDenied(){
        currentSendSubStreamState = SendSubStreamState.NORMAL;
        mSendSubStream.setImageResource(R.drawable.ic_r_sendassist_off);
        setSendSubStreamIconClickStatus(true);
        RxToast.error(getActivity(),R.string.conf_starting_sub_denied);
        LogUtil.e(TAG,"request send sub stream denied!");
    }

    /**
     * 该方法主要是为了清空 或者恢复 发送辅流按钮的点击事件
     * 当点击申请发送辅流时 申请发送辅流的按钮点击事件要置空
     * 当发送允许或者发送拒绝 要恢复发送按钮的点击事件
     * */
    public void setSendSubStreamIconClickStatus(boolean enable){
        if(enable){
            mSendSubStream.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if(currentSendSubStreamState == SendSubStreamState.SENDING){
                        stoppedSendSubStream();
                    }else{
                        showSendSubStreamDialog();
                    }
                }
            });
        }else{
            mSendSubStream.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {

                }
            });
        }
    }
    /**
     * 开始发送辅流
     * 第一次开启发送辅流时 直接设置发送窗口可见就可以了 会回调TextureView的available方法 在那里面做了初始化的操作 startSend(1)
     * 后面再对textureView 设置可见与不可见 都不会再重新回调 available 方法
     * isLocalSubViewAvailable会在 辅流发送窗口创建成功后置为true（默认是false）
     * 当暂停发送后重新恢复发送的时候（已经不是第一次发送辅流了）这时要调用 startSendOnly(1)
     * 因为 isLocalSubViewAvailable 第一次创建后被置true 所以后面都会走到if语句里
     * */
    public void startSendSubStream(){
            currentSendSubStreamState = SendSubStreamState.SENDING;
            setSendSubStreamIconClickStatus(true);
            mSendSubStream.setImageResource(R.drawable.ic_r_sendassist_on);
            RxToast.success(getActivity(),R.string.conf_starting_sub_stream_success);
            mLocalTextureViewSub.setVisibility(View.VISIBLE);
            LogUtil.d(TAG,"start send sub stream, currentDualDisplayState:"+currentDualDisplayState);
            if(isLocalSubViewAvailable){
                LogUtil.d(TAG,"start send sub stream, isLocalSubStreamAvailable?"+isLocalSubViewAvailable);
                WebRTCHelper.webrtc_startSendOnly(1);
            }
    }
    /**
     * 暂停发送辅流 调用stopSendOnly(1)
     * */
    public void stoppedSendSubStream() {
        if (currentDualDisplayState==DualDisplayState.NORMAL) {
            LinphoneManager.getLc().bfcpFloorReleaseSend();
            currentSendSubStreamState = SendSubStreamState.NORMAL;
            mSendSubStream.setImageResource(R.drawable.ic_r_sendassist_off);
            RxToast.success(getContext(), R.string.conf_sub_stream_send_stopped);
            WebRTCHelper.webrtc_stopSendOnly(1);
            mLocalTextureViewSub.setVisibility(View.INVISIBLE);
            LogUtil.d(TAG,"stop send sub stream, currentDualDisplayState:"+currentDualDisplayState);
        }
        else{
            LogUtil.d(TAG,"stop send sub stream, currentDualDisplayState:"+currentDualDisplayState);
            RxToast.warning(getActivity(),R.string.conf_quit_dual_display_warning); }
    }
    /**
     * 开启双屏异显(远端)
     * 因为副屏里重新赋值了MediaEngine的渲染对象 所以当关闭时
     * 要重新将CallVideoFragment中的mRemoteSubTextureView 赋值给MediaEngine
     * */
    public void showSecondRemoteScreen(){
        mDualDisplay.setImageResource(R.drawable.ic_r_twoscreen_on);
        currentViewState = ViewState.DUAL_DISPLAY_REMOTE;
        currentDualDisplayState = DualDisplayState.REMOTE;
        setViewMode(ViewState.DUAL_DISPLAY_REMOTE);
        mRemoteTextureViewSub.setVisibility(View.INVISIBLE);
        if(mSecondDisplay == null)
            mSecondDisplay =new SecondSubRemoteDisplayView(getActivity(),((DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE)).getDisplay(1));//displays[1]是副屏//displays[1]是副屏
        mSecondDisplay.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
        mSecondDisplay.show();
        LogUtil.d(TAG,"showSecondRemoteScreen");
    }
    /**
     * 关闭双屏异显（远端）
     * stopRecvOnly(1) 先关闭
     * setRemoteTextureView(1,mRemoteTextureViewSub) 重新将渲染对象设置回来
     * startRecvOnly(1) 再开启
     * */
    public void closeSecondRemoteScreen(){
        currentViewState = ViewState.REMOTE_MAIN;
        setViewMode(ViewState.REMOTE_MAIN);
        currentDualDisplayState = DualDisplayState.NORMAL;
        mDualDisplay.setImageResource(R.drawable.ic_r_twoscreen_off);
        RxToast.success(getContext(), R.string.conf_dual_display_stopped);
        if(mSecondDisplay != null){
            mSecondDisplay.cancel();
            LogUtil.d(TAG,"closeSecondRemoteScreen, second display has been canceled");
            mSecondDisplay = null;
        }
        mRemoteTextureViewSub.setVisibility(View.VISIBLE);
        WebRTCHelper.webrtc_stopReceiveOnly(1);
        WebRTCHelper.setRemoteTextureView(1, mRemoteTextureViewSub);
        WebRTCHelper.webrtc_startReceiveOnly(1);
        LogUtil.d(TAG,"closeSecondRemoteScreen");
    }
    /**
     * 开启双屏异显（本端）
     * stopSend(1) 先关闭摄像头
     * 开启第二屏（重新赋值第二屏的TextureView，重新初始化webrtc）
     * */
    public void showSecondLocalScreen(){
        mDualDisplay.setImageResource(R.drawable.ic_r_twoscreen_on);
        currentViewState = DUAL_DISPLAY_LOCAL;
        currentDualDisplayState = DualDisplayState.LOCAL;
        setViewMode(DUAL_DISPLAY_LOCAL);
        mLocalTextureViewSub.setVisibility(View.INVISIBLE);
        WebRTCHelper.stopSend(1);
        if(mSecondLocalDisplay == null)
            mSecondLocalDisplay =new SecondSubLocalDisplayView(getActivity(),((DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE)).getDisplay(1));//displays[1]是副屏//displays[1]是副屏
        mSecondLocalDisplay.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
        mSecondLocalDisplay.show();
        LogUtil.d(TAG,"showSecondLocalScreen");
    }
    /**
     * 关闭双屏异显（本端）
     * stopSend(1) 先关闭摄像头
     * 重新赋值视频界面的TextureView
     * 重新初始化webrtc
     * 重新开启发送通道
     * */
    public void closeSecondLocalScreen(){
        currentViewState = ViewState.REMOTE_MAIN;
        setViewMode(ViewState.REMOTE_MAIN);
        currentDualDisplayState = DualDisplayState.NORMAL;
        mDualDisplay.setImageResource(R.drawable.ic_r_twoscreen_off);
        RxToast.success(getContext(),R.string.conf_dual_display_stopped);
        if(mSecondLocalDisplay != null){
            mSecondLocalDisplay.cancel();
            LogUtil.d(TAG,"closeSecondLocalScreen, second display has been canceled");
            mSecondLocalDisplay = null;
        }
        mLocalTextureViewSub.setVisibility(View.VISIBLE);
        if(isLocalSubViewAvailable){
            WebRTCHelper.stopSend(1);
            WebRTCHelper.setLocalTextureView(1, mLocalTextureViewSub);
            WebRTCHelper.webrtc_init(1,currentCall);
            WebRTCHelper.webrtc_startSend(1);
            LogUtil.d(TAG,"closeSecondRemoteScreen");
        }
    }
// 初始化一些点击事件 包括双击全屏 双指缩放 之类的
    private void initListener(){
        info.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                updateDumpInfoVisiblity();
                doRefreshInfo();
            }
        });

        llLocalSurface.setCallback(new ScaleLinearLayout.ScaleCallBack() {
            @Override
            public void onScale(float rate) {

            }

            @Override
            public void fullScreen() {
                if(currentViewState == ViewState.LOCAL_MAIN || currentViewState == ViewState.ONE_STREAM_LOCAL)
                    doFullScreen();
            }

            @Override
            public void resetScale() {
                if(currentViewState == ViewState.LOCAL_MAIN || currentViewState == ViewState.ONE_STREAM_LOCAL)
                    setViewMode(currentViewState);
            }

            @Override
            public void singleClick() {
                if(currentViewState == ViewState.LOCAL_MAIN || currentViewState == ViewState.ONE_STREAM_LOCAL){
                    if (inCallActivity != null) inCallActivity.displayVideoCallControlsIfHidden();
                }else{
                    if(currentViewState == ViewState.ONE_STREAM_REMOTE)
                        setViewMode(ViewState.ONE_STREAM_LOCAL);
                    else
                        setViewMode(ViewState.LOCAL_MAIN);
                }
            }
            @Override
            public void firstDrag() {

            }
        });
        mRemoteTextureView.setCallback(new ScaledTextureView.ScaleCallBack() {
            /*双指首次放下回调*/
            @Override
            public void firstDrag() {
                if(currentViewState == ViewState.REMOTE_MAIN || currentViewState == ViewState.ONE_STREAM_REMOTE){
                    firstDragH = mRemoteTextureView.getHeight();
                    firstDragW = mRemoteTextureView.getWidth();
                }
            }

            @Override
            public void onScale(float rate) {
                if(currentViewState == ViewState.REMOTE_MAIN || currentViewState == ViewState.ONE_STREAM_REMOTE)
                    doOnScale(rate);
            }

            @Override
            public void fullScreen() {
                if(currentViewState == ViewState.REMOTE_MAIN || currentViewState == ViewState.ONE_STREAM_REMOTE)
                    doFullScreen();
            }

            @Override
            public void resetScale() {
                if(currentViewState == ViewState.REMOTE_MAIN || currentViewState == ViewState.ONE_STREAM_REMOTE)
                    doResetScale();
            }

            @Override
            public void singleClick() {
                /**
                 * 单击主流本端会回调该方法，这里需要与两个流和一个流的状态分开
                 * 如果只有一个流 点击后进入 ONE_STREAM_REMOTE 状态（主视窗宽1280 且分割线不显示）
                 * 有两个流 点击进入 REMOTE_MAIN 状态
                 * */
                if(currentViewState == ViewState.REMOTE_MAIN ||currentViewState == ViewState.ONE_STREAM_REMOTE){
                    if (inCallActivity != null) inCallActivity.displayVideoCallControlsIfHidden();
                }else {
                    if(currentViewState == ViewState.ONE_STREAM_LOCAL)
                        setViewMode(ViewState.ONE_STREAM_REMOTE);
                    else
                        setViewMode(ViewState.REMOTE_MAIN);
                }
            }
        });
        if(IPCallHelper.isSubStreamEnable(currentCall))
            llRemoteSurfaceSub.setCallback(new ScaleLinearLayout.ScaleCallBack() {
                @Override
                public void onScale(float rate) {

                }

                @Override
                public void fullScreen() {
                    if(currentViewState == ViewState.REMOTE_SUB)
                        doFullScreen();
                }

                @Override
                public void resetScale() {
                    if(currentViewState == ViewState.REMOTE_SUB)
                        setViewMode(REMOTE_SUB);
                }

                @Override
                public void singleClick() {
                    if(currentViewState == ViewState.REMOTE_SUB){
                        if (inCallActivity != null) inCallActivity.displayVideoCallControlsIfHidden();
                    }else {
                        setViewMode(ViewState.REMOTE_SUB);
                    }
                }

                @Override
                public void firstDrag() {

                }
            });
        if(IPCallHelper.isSubStreamEnable(currentCall))
            llLocalSurfaceSub.setCallback(new ScaleLinearLayout.ScaleCallBack() {
                @Override
                public void onScale(float rate) {

                }

                @Override
                public void fullScreen() {
                    if(currentViewState == ViewState.LOCAL_SUB)
                        doFullScreen();
                }

                @Override
                public void resetScale() {
                    if(currentViewState == ViewState.LOCAL_SUB)
                        setViewMode(ViewState.LOCAL_SUB);
                }

                @Override
                public void singleClick() {
                    if(currentViewState == ViewState.LOCAL_SUB){
                        if (inCallActivity != null) inCallActivity.displayVideoCallControlsIfHidden();
                    }else{
                        setViewMode(ViewState.LOCAL_SUB);
                    }
                }

                @Override
                public void firstDrag() {

                }
            });
            
            // 点击切换布局按钮 将支持的布局类型轮流切换一遍
            
        mChangeViewMode.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                switch (currentViewState){
                    case ONE_STREAM_LOCAL:
                        setViewMode(ONE_STREAM_REMOTE);
                        break;
                    case ONE_STREAM_REMOTE:
                        setViewMode(ONE_STREAM_LOCAL);
                        break;
                    case REMOTE_MAIN:
                    case DUAL_DISPLAY_LOCAL:
                    case DUAL_DISPLAY_REMOTE:
                        setViewMode(LOCAL_MAIN);
                        break;
                    case LOCAL_MAIN:
                        setViewMode(REMOTE_SUB);
                        break;
                    case REMOTE_SUB:
                        setViewMode(LOCAL_SUB);
                        break;
                    case LOCAL_SUB:
                        setViewMode(REMOTE_MAIN);
                        break;
                }
            }
        });
        // 点击全屏按钮 进入全屏
        mFullScreen.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                    if (!isFullScreen) doFullScreen();
                    else doResetScale();
            }
        });
        
        mSendSubStream.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if(currentSendSubStreamState == SendSubStreamState.SENDING){
                    stoppedSendSubStream();
                }else{
                    showSendSubStreamDialog();
                }
            }
        });
        mDualDisplay.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if(currentDualDisplayState == DualDisplayState.REMOTE){
                    closeSecondRemoteScreen();
                }else if(currentDualDisplayState == DualDisplayState.LOCAL){
                    closeSecondLocalScreen();
                }else{
                    showDualDisplayDialog();
                }
            }
        });
    }
    public void setControlPanelVisible(boolean isShow){
        if(mIconContainer!=null){
            if(isShow){
                mIconContainer.setVisibility(View.VISIBLE);
            }else
                mIconContainer.setVisibility(GONE);
        }
    }
    /**
     * 设置当前视图模式
     * ViewState.REMOTE_MAIN 对端主流优先显示
     * ViewState.LOCAL_MAIN 本端主流优先显示
     * ViewState.REMOTE_SUB 对端辅流优先显示
     * ViewState.LOCAL_SUB 本端辅流优先显示
     * ViewState.DUAL_DISPLAY_REMOTE 双屏异显
     * ViewState.ONE_STREAM_REMOTE 单流时主流优先
     * ViewState.ONE_STREAM_LOCAL 单流时辅流优先
     * */
    private void setViewMode(ViewState state){
        if(state == ViewState.REMOTE_MAIN){
            setAllViewVisible();
            enterRemoteMainMode();
        }else if(state == ViewState.REMOTE_SUB){
            setAllViewVisible();
            enterRemoteSubMode();
        }
        else if(state == ViewState.DUAL_DISPLAY_REMOTE){
            setAllViewVisible();
            enterDualDisplayRemoteMode();
        }
        else if(state == DUAL_DISPLAY_LOCAL){
            setAllViewVisible();
            enterDualDisplayLocalMode();

        }else if(state == ViewState.LOCAL_SUB){
            setAllViewVisible();
            enterLocalSubMode();
        }
        else if(state == ViewState.LOCAL_MAIN){
            setAllViewVisible();
            enterLocalMainMode();
        }else if(state == ViewState.ONE_STREAM_LOCAL){
            setAllViewVisible();
            enterOneStreamLocalMode();
        }
        else if(state == ViewState.ONE_STREAM_REMOTE){
            setAllViewVisible();
            enterOneStreamRemoteMode();
        }
        LogUtil.d(TAG,"currentViewState:"+currentViewState);
    }
    
    private void enterRemoteMainMode(){
       ···
    }
    ···
    // 获取当前视频信息 这是当在设置中开启了显示视频参数
    // 然后视频界面会出现一个视频信息的图标，点击该图标，就会创建个
    //Textview 不停的刷新获取当前视频参数。
    private void updateDumpInfoVisiblity(){
        if(videoInfo.getVisibility() == GONE){
            videoInfo.setVisibility(View.VISIBLE);
            info.setImageResource(R.drawable.ic_r_info_off);
        }else{
            videoInfo.setVisibility(GONE);
            info.setImageResource(R.drawable.ic_r_info_on);
        }

    }
    private void doRefreshInfo(){
        if(videoInfo!=null){
            if(videoInfo.getVisibility() == GONE)
                stopRefreshInfo();
            else startRefreshInfo();
        }
    }
    private Runnable r = new Runnable() {
        @Override
        public void run() {
            if(videoInfo!=null){
                videoInfo.setText(updateDump(currentCall));
            }
            mHandler.postDelayed(r, 1000);
        }
    };
    // 间隔一秒种 刷新一下视频数据
    private void startRefreshInfo() {
        stopRefreshInfo();
        mHandler.post(r);
    }

    private void stopRefreshInfo() {
        mHandler.removeCallbacks(r);
    }
    private String updateDump(LinphoneCall call){
        if(call!=null){
            String dump_info = "";
            dump_info += getLocalVideoInfo(call.getCurrentParamsCopy(),call.getRemoteParams());
            dump_info += "\n"+getRemoteVideoInfo(call.getRemoteParams());
            return dump_info;
        }
        return "";
    }
    
    // 获取本端视频参数
    private String getLocalVideoInfo(LinphoneCallParams callLocalParams, LinphoneCallParams callRemoteParams){
       ···

        return local;
    }
// 获取对端视频参数
    private String getRemoteVideoInfo(LinphoneCallParams callParams){
        String local = "";
        ···
        return local;
    }

    private String getResolution(){
        int index = LinphoneManager.getInstance().getEngine().getResolutionIndex();
        if(MediaEngine.getResolutions()!=null){
            return  MediaEngine.resolutionsAsString()[index];
        }else return "";
    }
    @Override
    public void onStart() {
        super.onStart();
        LogUtil.v(TAG,"onStart");
    }

    @Override
    public void onResume() {
        super.onResume();
        LogUtil.v(TAG,"onResume");
        doRefreshInfo();
        IntentFilter filter = new IntentFilter();
        filter.addAction(INTENT_INCOMING_VIDEO_SIZE);
        filter.addAction(INTENT_HDMI);
        // onResume的时候 注册一个监听底层上报视频宽高的广播
        incomingVideoSizeReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if(intent.getAction()!=null){
                    switch (intent.getAction()){
                        case INTENT_INCOMING_VIDEO_SIZE:
                            setLocalView(true);
                            int width = intent.getIntExtra("width", -1);
                            int height = intent.getIntExtra("height", -1);
                            receivedHeight = height;
                            receivedWidth = width;
                            setInComingViewSize(width, height);
                            break;
                            // 这个HDMI的插拔广播暂时是不用的
                        case INTENT_HDMI:
                            boolean status = intent.getBooleanExtra("status",false);
                            isHDMIAvailable = status;
                            if(status){
                                showSendRequestDialog();
                            }
                            break;
                    }
                }
            }
        };
        TelpoService.instance().registerReceiver(incomingVideoSizeReceiver, filter);
        setInComingViewSize(receivedWidth, receivedHeight);
        setLocalView(true);
        if (androidVideoWindowImpl != null) {
            synchronized (androidVideoWindowImpl) {
                LinphoneManager.getLc().setVideoWindow(androidVideoWindowImpl);
            }
        }
        resumeWebrtc();
        WebRTCHelper.setOrientation(getActivity());
        MediaEngine.HAS_BEEN_SEND = false;
        updateIconStatus();
        setViewMode(currentViewState);
    }

// 根据当前的状态 刷新一下各个icon的状态 
    private void updateIconStatus(){
    // 正在发送辅流 更新辅流按钮的图标和点击事件
        if(currentSendSubStreamState == SendSubStreamState.SENDING){
            mSendSubStream.setImageResource(R.drawable.ic_r_sendassist_on);
            setSendSubStreamIconClickStatus(true);
            // 正在请求发送辅流 更新辅流按钮的图标 并令其不可点击
        }else if(currentSendSubStreamState == SendSubStreamState.REQUEST){
            mSendSubStream.setImageResource(R.drawable.ic_r_sendassist_off);
            setSendSubStreamIconClickStatus(false);
        }else{
  // 辅流请求失败 更新图标 并令其可点击     
  mSendSubStream.setImageResource(R.drawable.ic_r_sendassist_off);
            setSendSubStreamIconClickStatus(true);
        }
        // 根据当前是否在双屏异显中 去更新双屏异显的icon状态
        if(currentDualDisplayState != DualDisplayState.NORMAL){
            mDualDisplay.setImageResource(R.drawable.ic_r_twoscreen_on);
        }else mDualDisplay.setImageResource(R.drawable.ic_r_twoscreen_off);
    }
// 设置主流视频宽高
    private void setLocalView(boolean initSuccess){
        if(initSuccess){
            ViewGroup.LayoutParams layoutParams = llLocalSurface.getLayoutParams();
            layoutParams.width = (int) getResources().getDimension(R.dimen.local_video_width);
            layoutParams.height = (int) getResources().getDimension(R.dimen.local_video_height);
            llLocalSurface.setLayoutParams(layoutParams);
        }
    }

    @Override
    public void onPause() {
        LogUtil.v(TAG,"onPause");
        stopRefreshInfo();
        if (androidVideoWindowImpl != null) {
            synchronized (androidVideoWindowImpl) {
                LinphoneManager.getLc().setVideoWindow(null);
            }
        }
        TelpoService.instance().unregisterReceiver(incomingVideoSizeReceiver);
        pauseWebrtc();
        super.onPause();
    }

    // 当视频切到后台 暂停webrtc
    public void pauseWebrtc(){
        LogUtil.d(TAG,"pause webrtc, is webrtc been init? "+WebRTCHelper.webrtcInited
                +"is webrtc sub been init? "+WebRTCHelper.subWebrtcInited);
        if(WebRTCHelper.webrtcInited){
            WebRTCHelper.webrtc_stopSendOnly(0);
            WebRTCHelper.webrtc_stopReceiveOnly(0);
        }
        if(WebRTCHelper.subWebrtcInited){
            WebRTCHelper.webrtc_stopSendOnly(1);
            WebRTCHelper.webrtc_stopReceiveOnly(1);
        }
    }
// 视频界面切换回来后 恢复webrtc
    public void resumeWebrtc(){
        LogUtil.d(TAG,"resume webrtc, is webrtc been init? "+WebRTCHelper.webrtcInited
        +"is webrtc sub been init? "+WebRTCHelper.subWebrtcInited);
        if(WebRTCHelper.webrtcInited){
            WebRTCHelper.webrtc_startSendOnly(0);
            WebRTCHelper.webrtc_startReceiveOnly(0);
        }
        if(WebRTCHelper.subWebrtcInited){
            WebRTCHelper.webrtc_startSendOnly(1);
            WebRTCHelper.webrtc_startReceiveOnly(1);
        }
    }


        @Override
    public void onDestroy() {
        LogUtil.v(TAG,"onDestroy");
        stopRefreshInfo();
        mHandler = null;
        closeDualDisplay();
        if(inCallActivity!=null){
            inCallActivity.setIsInVideoMode(false);
        }
        inCallActivity = null;
        MediaEngine.HAS_BEEN_SEND = false;
        if (androidVideoWindowImpl != null) {
            // Prevent linphone from crashing if correspondent hang up while you are rotating
            androidVideoWindowImpl.release();
            androidVideoWindowImpl = null;
        }
        resetWebrtc();
        super.onDestroy();
    }
    private void closeDualDisplay(){
        if(mSecondDisplay != null){
            if(mSecondDisplay.isShowing()){
                mSecondDisplay.cancel();
                mSecondDisplay = null;
                LogUtil.w(TAG,"fragment destroy but the dual display dialog has not been" +
                        "destroy. close it manually");
            }
        }
        if(mSecondLocalDisplay != null){
            if(mSecondLocalDisplay.isShowing()){
                mSecondLocalDisplay.cancel();
                mSecondLocalDisplay = null;
                LogUtil.w(TAG,"fragment destroy but the dual display dialog has not been" +
                        "destroy. close it manually");
            }
        }
    }
    
    /**
     * 当暂停辅流发送的时候 调用的stopSendOnly
     * stopSendOnly的时候标志位变了 stopSend方法其实没有被真实调用 摄像头没有被销毁
     * 所以会出现 当挂机时状态是辅流发送暂停的状态时  下次呼叫会因为摄像头未释放而一直不能发起辅流
     * 临时的解决办法是在挂机的时候先调用一次startSendOnly（）
     * */

    private void resetWebrtc(){
        WebRTCHelper.webrtcInited = false;
        WebRTCHelper.subWebrtcInited = false;
        WebRTCHelper.webrtcPreInited = false;
        WebRTCHelper.subWebrtcPreInited = false;
        WebRTCHelper.webrtc_startSendOnly(1);
        WebRTCHelper.webrtc_startSendOnly(0);
        WebRTCHelper.webrtc_stopSend(1);
        WebRTCHelper.webrtc_stopReceived(1);
        WebRTCHelper.webrtc_stopSend(0);
        WebRTCHelper.webrtc_stopReceived(0);
        LogUtil.v(TAG,"resetWebrtc");
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        if(activity instanceof CallActivity){
            inCallActivity = (CallActivity) activity;
            if (inCallActivity != null) {
                inCallActivity.bindVideoFragment(this);
            }
        }
    }

    /**
     * 为了规避切换界面时花屏
     * */
    public void hiddenAllTextureView(){
        mLocalTextureViewSub.setVisibility(View.INVISIBLE);
        mLocalTextureView.setVisibility(View.INVISIBLE);
        mRemoteTextureView.setVisibility(View.INVISIBLE);
        mRemoteTextureViewSub.setVisibility(View.INVISIBLE);
        line.setVisibility(View.INVISIBLE);
    }
    
    // 设置视频的尺寸

    private void setInComingViewSize(int width, int height) {
        if (width >= 0 && height >= 0) {
            WindowManager wm = getActivity().getWindowManager();
            Point screen = new Point();
            wm.getDefaultDisplay().getSize(screen);
            int screenWidth = (int)screenW;
            int screenHeight = screen.y;
            double widthRatio, heightRatio, scale;
            widthRatio = screenWidth / (width * 1.0);
            heightRatio = screenHeight / (height * 1.0);
            double minScale = Math.min(widthRatio,heightRatio);
            setWidth = (int) (width * minScale);
            setHeight = (int) (height * minScale);
            LogUtil.d(TAG,"incoming video size received"+"width--->"+ setWidth +"height--->"+ setHeight);
            if(currentViewState == ViewState.REMOTE_MAIN||currentViewState == ViewState.ONE_STREAM_REMOTE){
                ViewGroup.LayoutParams params = mRemoteTextureView.getLayoutParams();
                params.width = (int)setWidth;
                params.height = (int) setHeight;
                mRemoteTextureView.setLayoutParams(params);
            }
           LogUtil.d(TAG, String.format("remote view param, videoWidth=%d, videoHeight=%d, "
                            + "screenWidth=%d, screenHeight=%d, setWidth=%d, setHeight=%d", width, height,
                    screenWidth, screenHeight, (int)setWidth, (int)setHeight));
        }
    }



}

```


#### 2. webrtcHelper

对MediaEngine做的一层封装

```java
public class WebRTCHelper {
    private static final String TAG = "wx.helper.webrtc";
    // 判断视频是否初始化过的标志位
    // webrtc不允许多次初始化 不然会报错
    public static boolean webrtcInited = false;
    public static boolean subWebrtcInited = false;
    // 判断是否携带视频参数 是否是视频通话
    public static boolean isVideoEnabled(LinphoneCall call) {
        return IPCallHelper.isVideoEnabled(call);
    }
    //是否携带辅流
    public static boolean isSubVideoEnable(LinphoneCall call){
        if(call != null){
            return call.getCurrentParamsCopy().getVideoEnabled();
        }
        return false;
    }
    // 发送辅流的穿透包到对端 目前的机制是当辅流通道开始建立之后，linphone 底层会通知上层定期发送
    // 该穿透包，间隔时间为1s
    public static void webrtc_sendrtp_sub(LinphoneCall call) {
        if ((callRemoteParams.getRemoteVideo2RtpAddress() == null) || (callLocalParams.getLocalVideo2RtpAddress() == null)) {
            return;
        }
        sendBytesSub(callLocalParams.getLocalVideo2RtpAddress(), callLocalParams.getLocalVideo2RtpPort(),
                callRemoteParams.getRemoteVideo2RtpAddress(), callRemoteParams.getRemoteVideo2RtpPort());
    }
    // 主流暂时不需要定时发送穿透
    public static void webrtc_sendrtp(LinphoneCall call) {
//        if ((callRemoteParams.getRemoteVideoRtpAddress() == null) || (callLocalParams.getLocalVideoRtpAddress() == null)) {
//            return;
//        }
//        sendBytes(callLocalParams.getLocalVideoRtpAddress(), callLocalParams.getLocalVideoRtpPort(),
//                callRemoteParams.getRemoteVideoRtpAddress(), callRemoteParams.getRemoteVideoRtpPort());
    }
    // 初始化webrtc 主流为0 辅流为1
    public static void webrtc_init(int index,LinphoneCall call){
        if(index == 0){
            if (isVideoEnabled(call)) {
                org.linphone.util.LogUtil.d(TAG, "------ isVideoEnabled(call)=" + isVideoEnabled(call));
                webrtc_config(call);
            }
        }else if(index == 1){
            webrtc_config_sub(call);
        }
    }

    public static void setOrientation(Activity activity){
        int rotation = activity.getWindowManager().getDefaultDisplay().getOrientation();
        int degrees = 0;
        switch (rotation) {
            case Surface.ROTATION_0: degrees = 0; break;
            case Surface.ROTATION_90: degrees = 90; break;
            case Surface.ROTATION_180: degrees = 180; break;
            case Surface.ROTATION_270: degrees = 90; break;
        }
        Log.w(TAG, "rotation="+rotation+",degrees="+degrees);
    }
    //初始化webrtc 并初始化一些设置项
    public static void webrtc_config_sub(LinphoneCall call){
        // 只能初始化一次
        if (subWebrtcInited) {
            org.linphone.util.LogUtil.d(TAG, "webrtc had init, return");
            return;
        }else{
            subWebrtcInited = true;
            LinphoneManager.getInstance().getEngine().init(1); /* 重新创建通道 */
        }
        org.linphone.util.LogUtil.d(TAG, String.format("call param: remote port sub=%d, remote address sub =%s, local port sub =%d, local address sub=%s",
                callRemoteParams.getRemoteVideo2RtpPort(), callRemoteParams.getRemoteVideo2RtpAddress(),
                callLocalParams.getLocalVideo2RtpPort(), callLocalParams.getLocalVideo2RtpAddress()));

        if ((callRemoteParams.getRemoteVideo2RtpAddress() == null) || (callLocalParams.getLocalVideo2RtpAddress() == null)) {
            return;
        }
        // 发送一次rtp信息到对端服务器
        sendBytesSub(callLocalParams.getLocalVideo2RtpAddress(), callLocalParams.getLocalVideo2RtpPort(),
                callRemoteParams.getRemoteVideo2RtpAddress(), callRemoteParams.getRemoteVideo2RtpPort());

        if (call.getCurrentParamsCopy().getUsedVideo2Codec() == null) {
            org.linphone.util.LogUtil.d(TAG, "getUsedVideoCodec() == null, dismiss webrtc_config");
            return;
        }
        // 根据分辨率设置对应的视频宽高
        MediaEngine mediaEngine = LinphoneManager.getInstance().getEngine();
        String preset = LinphoneManager.getLcIfManagerNotDestroyedOrNull().getConfig().getString(
                "video", "size", "vga");
        if (preset.equals("720p")) {
            mediaEngine.setResolutionIndex(1, MediaEngine.RESOLUTIONS_720P);
        } else if (preset.equals("vga")) {
            mediaEngine.setResolutionIndex(1, MediaEngine.RESOLUTIONS_VGA);
        } else if (preset.equals("cif")) {
            mediaEngine.setResolutionIndex(1, MediaEngine.RESOLUTIONS_CIF);
        } else if (preset.equals("qvga")) {
            mediaEngine.setResolutionIndex(1, MediaEngine.RESOLUTIONS_QVGA);
        } else if (preset.equals("4cif")) {
            mediaEngine.setResolutionIndex(1, MediaEngine.RESOLUTIONS_4CIF);
        } else if (preset.equals("qcif")) {
            mediaEngine.setResolutionIndex(1, MediaEngine.RESOLUTIONS_QCIF);
        } else if(preset.equals("1080p")){
            mediaEngine.setResolutionIndex(1, MediaEngine.RESOLUTIONS_1080P);
        }
        else {
            mediaEngine.setResolutionIndex(0, MediaEngine.RESOLUTIONS_VGA);
        }
        // 设置带宽
        int bitrate = LinphoneManager.getLcIfManagerNotDestroyedOrNull().getDownloadBandwidth();
        // 辅流帧率默认为15帧
        mediaEngine.setFps(1,15);
        mediaEngine.setBitRate(1,bitrate);
        // webrtc不做与音频相关的任何操作，音频是linphone层
        mediaEngine.setAudio(false);
        // 是否开启解码
        mediaEngine.setReceiveVideo(1,true);
        // 是否开启编码
        mediaEngine.setSendVideo(1,true);
        mediaEngine.setViewSelection(1,0);
        // 是否开启日志打印
        mediaEngine.setNack(1,true);
        // payloadtype
        int payloadtype = LinphoneManager.getLcIfManagerNotDestroyedOrNull().getPayloadTypeNumber(
                callLocalParams.getUsedVideoCodec());
        // 从协商中获取payload值
        mediaEngine.setPLType(payloadtype);
//        LinphoneManager.getInstance().getEngine().setHybridNACKFECStatus(1, true, payloadtype, payloadtype);/*使用这个调用*/
        /* 设置编码格式 */
        if ("VP8".equals(LinphoneManager.getLc().getCurrentCall().getCurrentParamsCopy()
                .getUsedVideo2Codec().getMime())) {
            mediaEngine.setVideoCodec(1,0);
        } else if ("VP9".equals(LinphoneManager.getLc().getCurrentCall().getCurrentParamsCopy()
                .getUsedVideo2Codec().getMime())) {
            mediaEngine.setVideoCodec(1,1);
        } else if ("H264".equals(LinphoneManager.getLc().getCurrentCall().getCurrentParamsCopy()
                .getUsedVideo2Codec().getMime())) {
            // fec接收参数设置
            mediaEngine.setVideoCodec(1,2);
        } else if ("H263".equals(LinphoneManager.getLc().getCurrentCall().getCurrentParamsCopy()
                .getUsedVideo2Codec().getMime())) {
            mediaEngine.setVideoCodec(1,3);
        }
        // 设置DSCP
        if(LinphoneManager.getLc()!=null){
     //       int result = mediaEngine.setDscp(1,LinphoneManager.getLc().getVideoDscp());
     //       LogUtil.d(TAG,"set dscp index : 1,code = "+LinphoneManager.getLc().getVideoDscp()+", result = "+result);
        }
        /* 配置本端 ip  和 端口 */
        mediaEngine.setVideoRxPortAndIP(1,
                callLocalParams.getLocalVideo2RtpPort(),
                callLocalParams.getLocalVideo2RtpAddress());
        /* 配置对端 IP 和 端口 */
        mediaEngine.setRemoteIp(1,callRemoteParams.getRemoteVideo2RtpAddress());
        mediaEngine.setVideoTxPort(1,callRemoteParams.getRemoteVideo2RtpPort());
    }
    // 初始化主流的webrtc信息
    public static void webrtc_config(LinphoneCall call) {
        if (webrtcInited) {
            org.linphone.util.LogUtil.d(TAG, "webrtc had init, return");
            return;
        }else{
            LinphoneManager.getInstance().getEngine().init(0); /* 重新创建通道 */
            webrtcInited = true;
        }
        org.linphone.util.LogUtil.d(TAG, String.format("call param: remote port=%d, remote address=%s, local port=%d, local address=%s",
                callRemoteParams.getRemoteVideoRtpPort(), callRemoteParams.getRemoteVideoRtpAddress(),
                callLocalParams.getLocalVideoRtpPort(), callLocalParams.getLocalVideoRtpAddress()));

        if ((callRemoteParams.getRemoteVideoRtpAddress() == null) || (callLocalParams.getLocalVideoRtpAddress() == null)) {
            return;
        }

        sendBytes(callLocalParams.getLocalVideoRtpAddress(), callLocalParams.getLocalVideoRtpPort(),
                callRemoteParams.getRemoteVideoRtpAddress(), callRemoteParams.getRemoteVideoRtpPort());

        if (call.getCurrentParamsCopy().getUsedVideoCodec() == null) {
            org.linphone.util.LogUtil.d(TAG, "getUsedVideoCodec() == null, dismiss webrtc_config");
            return;
        }



        MediaEngine mediaEngine = LinphoneManager.getInstance().getEngine();
        String preset = LinphoneManager.getLcIfManagerNotDestroyedOrNull().getConfig().getString(
                "video", "size", "vga");
        if (preset.equals("720p")) {
            mediaEngine.setResolutionIndex(0, MediaEngine.RESOLUTIONS_720P);
        } else if (preset.equals("vga")) {
            mediaEngine.setResolutionIndex(0, MediaEngine.RESOLUTIONS_VGA);
        } else if (preset.equals("cif")) {
            mediaEngine.setResolutionIndex(0, MediaEngine.RESOLUTIONS_CIF);
        } else if (preset.equals("qvga")) {
            mediaEngine.setResolutionIndex(0, MediaEngine.RESOLUTIONS_QVGA);
        } else if (preset.equals("4cif")) {
            mediaEngine.setResolutionIndex(0, MediaEngine.RESOLUTIONS_4CIF);
        } else if (preset.equals("qcif")) {
            mediaEngine.setResolutionIndex(0, MediaEngine.RESOLUTIONS_QCIF);
        } else if(preset.equals("1080p")){
            mediaEngine.setResolutionIndex(0, MediaEngine.RESOLUTIONS_1080P);
        }
        else {
            mediaEngine.setResolutionIndex(0, MediaEngine.RESOLUTIONS_VGA);
        }
        int fps = (int) LinphoneManager.getLcIfManagerNotDestroyedOrNull().getPreferredFramerate();
        int bitrate = LinphoneManager.getLcIfManagerNotDestroyedOrNull().getDownloadBandwidth();
        org.linphone.util.LogUtil.d(TAG,
                String.format("mime=%s, size=%s, fps=%d, bitrate=%d",
                        call.getCurrentParamsCopy().getUsedVideoCodec().getMime(),
                        preset, fps, bitrate));
        mediaEngine.setFps(0,fps);
        mediaEngine.setBitRate(0,bitrate);
        mediaEngine.setAudio(false);
        mediaEngine.setReceiveVideo(0,true);
        if(SettingUtils.getInstance()!=null){
            mediaEngine.setSendVideo(0,!SettingUtils.getInstance().getOneWayVideoCall());
        }else{
            mediaEngine.setSendVideo(0,true);
        }
        Boolean isEnable = SystemProperties.getBoolean("video_log_enable",false);
        Log.e("WebrtcLogEnable",isEnable+"");
        mediaEngine.setTrace(isEnable);
        mediaEngine.setViewSelection(0,0);
        mediaEngine.setNack(0,true);
        // payloadtype
        int payloadtype = LinphoneManager.getLcIfManagerNotDestroyedOrNull().getPayloadTypeNumber(
                callLocalParams.getUsedVideoCodec());
        mediaEngine.setPLType(payloadtype);
        /* 设置编码格式 */
        if ("VP8".equals(LinphoneManager.getLc().getCurrentCall().getCurrentParamsCopy()
                .getUsedVideoCodec().getMime())) {
            mediaEngine.setVideoCodec(0,0);
        } else if ("VP9".equals(LinphoneManager.getLc().getCurrentCall().getCurrentParamsCopy()
                .getUsedVideoCodec().getMime())) {
            mediaEngine.setVideoCodec(0,1);
        } else if ("H264".equals(LinphoneManager.getLc().getCurrentCall().getCurrentParamsCopy()
                .getUsedVideoCodec().getMime())) {
            // fec接收参数设置
            mediaEngine.setVideoCodec(0,2);
        } else if ("H263".equals(LinphoneManager.getLc().getCurrentCall().getCurrentParamsCopy()
                .getUsedVideoCodec().getMime())) {
            mediaEngine.setVideoCodec(0,3);
        }
        /* 配置本端 ip  和 端口 */
        mediaEngine.setVideoRxPortAndIP(0,
                callLocalParams.getLocalVideoRtpPort(),
                callLocalParams.getLocalVideoRtpAddress());
        /* 配置对端 IP 和 端口 */
        mediaEngine.setRemoteIp(0,callRemoteParams.getRemoteVideoRtpAddress());
        mediaEngine.setVideoTxPort(0,callRemoteParams.getRemoteVideoRtpPort());
    }
    //开始接受 0为主流 1为辅流
    public static void webrtc_startReceive(int index){
        if(!LinphoneManager.getInstance().getEngine().isRecvRunning(index)){
            LinphoneManager.getInstance().getEngine().startRecv(index);
        }
    }
    // 开始发送
    public static void webrtc_startSend(int index){
        if(!LinphoneManager.getInstance().getEngine().isSendRunning(index)){
            LinphoneManager.getInstance().getEngine().startSend(index);
        }
    }
    //判断辅流是否在发送中
    public static boolean isStreamSending(int index){
        return LinphoneManager.getInstance().getEngine().isSendRunning(index);
    }
    // 停止发送 并销毁通道 但是要先判断是否正在发送
    public static void webrtc_stopSend(int index){
        if (LinphoneManager.getInstance().getEngine().isSendRunning(index)) { // 先判断当前是否在运行
            LinphoneManager.getInstance().getEngine().stopSend(index); /* 停止视频引擎发送 */
        }
		/* for webrtc */
        LinphoneManager.getInstance().getEngine().uninit(index); /* 销毁通道 */
    }
    // 停止接收  并销毁通道 还是要判断是否正在接收
    public static void webrtc_stopReceived(int index){
        if(LinphoneManager.getInstance().getEngine().isRecvRunning(index)) { // 先判断当前是否在运行
            LinphoneManager.getInstance().getEngine().stopRecv(index); /* 停止视频引擎 */
        }
        LinphoneManager.getInstance().getEngine().uninit(index);
    }

    // 暂停发送 注意要和停止发送区分 此时并没有销毁webrtc通道
    public static void webrtc_stopSendOnly(int index){
        LinphoneManager.getInstance().getEngine().stopSendOnly(index);
    }
    // 暂停接收 注意要和停止接收区分 此时也没有销毁webrtc通道
    public static void webrtc_stopReceiveOnly(int index){
        LinphoneManager.getInstance().getEngine().stopRecvOnly(index);
    }
    // 恢复发送 不销毁通道
    public static void webrtc_startSendOnly(int index){
        LinphoneManager.getInstance().getEngine().startSendOnly(index);
    }
    //恢复接收 不销毁通道
    public static void webrtc_startReceiveOnly(int index){
        LinphoneManager.getInstance().getEngine().startRecvOnly(index);
    }
    // 仅仅停止发送 但是没有销毁通道 此时会关闭摄像头
    public static void stopSend(int index){
        LinphoneManager.getInstance().getEngine().stopSend(index);
    }
    // 设置本端的渲染TextureView
    public static void setLocalTextureView(int index, TextureView tv){
        LinphoneManager.getInstance().getEngine().setLocalTextureView(index, tv);
    }
    // 设置对端的渲染TextureView
    public static void setRemoteTextureView(int index, TextureView tv){
        LinphoneManager.getInstance().getEngine().setRemoteTextureView(index, tv);
    }

    private static void sendBytes(String localIp, int localPort, String remoteIp, int remotePort) {
        /* 发送视频data数据到云端 */
        byte[] data = new byte[3];
        data[0] = 0x1;
        data[1] = 0x1;
        data[2] = 0x1;
        int transmittedBytes = 0;
        LinphoneManager.getInstance().getEngine().SetLocalSendPortAndIP(0,localPort, localIp); /* 可以只设置端口，ip预留目前不起作用 */
        LinphoneManager.getInstance().getEngine().SendAnyVideoDataToCloud(0,remotePort, remoteIp, data, 3, transmittedBytes);
        org.linphone.util.LogUtil.d(TAG, String.format(
                "send bytes, remote port=%d, ip=%s, local port=%d, ip=%s", remotePort, remoteIp,
                localPort, localIp));
        org.linphone.util.LogUtil.d(TAG, "transmittedBytes＝" + transmittedBytes);
    }
    private static void sendBytesSub(String localIp, int localPort, String remoteIp, int remotePort) {
        /* 发送视频data数据到云端 */
        byte[] data = new byte[3];
        data[0] = 0x1;
        data[1] = 0x1;
        data[2] = 0x1;
        int transmittedBytes = 0;
        LinphoneManager.getInstance().getEngine().SetLocalSendPortAndIP(1,localPort, localIp); /* 可以只设置端口，ip预留目前不起作用 */
        LinphoneManager.getInstance().getEngine().SendAnyVideoDataToCloud(1,remotePort, remoteIp, data, 3, transmittedBytes);
        org.linphone.util.LogUtil.d(TAG, String.format(
                "send bytes, remote port=%d, ip=%s, local port=%d, ip=%s", remotePort, remoteIp,
                localPort, localIp));
        org.linphone.util.LogUtil.d(TAG, "transmittedBytes＝" + transmittedBytes);
    }
}

```

#### 3 视频建立流程:
视频通话的建立流程是这样的

1. 通过`linphone`底层库 使用sip协议进行会话协商
2. 获取协商后的`sdp`信息以及**对端、本端的端口和IP**
3. 判断会话参数是否携带视频信息，如果携带，就打开`CallVideoFragment`
3. 打开`CallVideoFragment`
4. `CallVideoFragment`中有四个`TextureView`，它们分别负责 主流中 本端、对端的预览，辅流中 本端、对端的预览。这四个`TextureView`放在一个自定义的`ScaleLinearLayout`中，`ScaleLinearLayout`继承自`LinearLayout`，但是复写了`onTouch() `方法，会监听用户手势，当单击时，回调`singleClick()`, 双指缩放的时候，会回调`onScale()`，双击时会轮流调用 全屏 `fullScreen()` 和 恢复原始状态 `resetScale()` 方法。有一个特殊的`TextureView` 就是对端主流的`TextureView` 默认也是实现了这些手势检测的方法的，所以对端主流的`TextureView`是可以进行画面的缩放。 
5. 在创建`CallVideoFragment`的时候，会优先判断 该会话是否携带辅流参数。如果携带辅流，在`CallVideoFragment`创建的时候，就会默认打开辅流显示窗口。如果不携带辅流，就默认关闭辅流显示窗口。
6. 在每一个`TextureView`初始化的时候，会为其设置一个`SurfaceTextureListener` 监听器。这个监听器的`onSurfaceAvailable()`方法会在`TextureView`完成初始化之后回调。
7. 为`TextureView`的父布局，也就是各个`ScaleLinearLayout`设置点击事件的回调，为特殊的`TextureView`设置缩放事件的回调。
8. 当6中的`TextureView`初始化完成之后，会回调`onSurfaceAvailable()`,在该方法中，

```java
// 将当前TextureView设置给webrtc
WebRTCHelper.setLocalTextureView(0, mLocalTextureView);
// 如果是对端视频窗口，需要调用
// WebRTCHelper.setRemoteTextureView(0, mRemoteTextureView);
// 初始化webrtc 
WebRTCHelper.webrtc_init(0,currentCall);
// 开始发送本段画面
WebRTCHelper.webrtc_startSend(0);

```
9 . `setLocalTextureView()` 将`TextureView`设置给`VideoCaptureAndroid`的`mSurface`作为本端预览的渲染画面。

10 .`setRemoteTextureView()` 将`TextureView`设置给`MediaEngine`的`svRemoteTextureView` 用作渲染解码器解码后的图像

11 .初始化webrtc `WebRTCHelper.webrtc_init(0,currentCall);`
在`webrtc_init()`方法中，

```java
// a. 发送一次rtp包到对端
sendBytesSub(callLocalParams.getLocalVideo2RtpAddress(), callLocalParams.getLocalVideo2RtpPort(),
                callRemoteParams.getRemoteVideo2RtpAddress(), callRemoteParams.getRemoteVideo2RtpPort());
// b. 根据web上配置的分辨率参数 将分辨率设置给MediaEngine
mediaEngine.setResolutionIndex(1, MediaEngine.RESOLUTIONS_1080P);
// c. 设置带宽
mediaEngine.setBitRate(1,bitrate);
// d. 设置帧率
mediaEngine.setFps(1,15);
// e. webrtc不做与音频相关的任何操作，音频是linphone层
mediaEngine.setAudio(false);
// f. 是否开启解码
mediaEngine.setReceiveVideo(1,true);
// g. 是否开启编码
mediaEngine.setSendVideo(1,true);
mediaEngine.setViewSelection(1,0);
// h. 是否开启日志打印
mediaEngine.setNack(1,true);
// i. 设置编码格式
mediaEngine.setVideoCodec(1,0);
// j.配置本端 ip  和 端口 
mediaEngine.setVideoRxPortAndIP(1,callLocalParams.getLocalVideo2RtpPort(),callLocalParams.getLocalVideo2RtpAddress());
// k. 配置对端 IP 和 端口
mediaEngine.setRemoteIp(1,callRemoteParams.getRemoteVideo2RtpAddress());    
mediaEngine.setVideoTxPort(1,callRemoteParams.getRemoteVideo2RtpPort());
```
完成了对mediaEngine的初始化配置。

12 .`WebRTCHelper.webrtc_startSend(0);`开启视频引擎发送视频
13 .调用`MediaEngine.startCamera() `根据camera 的id 打开对应的相机
14. 调用`VideoEngine.startCapture()`开始视频采集，这是个native方法
15. 调用`VideoEngine.startSend() `开始发送数据
16. 如果是解码对端视频，调用`MediaEngine.startViERecv()`
17. `VideoEngine.addRenderer()`添加渲染`TextureView`
18. `VideoEngine.startRender()` 开启渲染
19. `VideoEngine.startReceive()` 开始解码对端视频
20. 视频图像就开始显示了

### WebrtcHelper调用的注意事项
#### 1. 主流辅流的通道数
**主流 index = 0；
辅流 index = 1；**

#### 2. 设置渲染对象
`WebRTCHelper.setRemoteTextureView(0, mRemoteTextureView);`
在任何地方调用该方法，都务必要保证 对应的TextureView 是available的，也就是要保证回调了onTextureViewAvailable()方法，你可以设置一个标记位来判断。
#### 3. 开启本端双屏异显

所谓双屏异显，其实就是弹出一个特殊的`Dialog`，这个`Dialog`是`Presentation`类，它继承`Dialog`，相当于另外一个屏幕，当你外接hdmi的时候，默认hdmi的画面是与当前设备的画面同步的，但是当你show了一个`Presentation`，并在`Presentation`中设置了一些自定义的布局，hdmi外接的屏幕就会显示`presentation`中的画面了。

实现将本端辅流的画面通过hdmi投影到对端，就是要创建一个`Presentation`，在`Presentation`开启webrtc，将本端相机采集到的视频画面显示在`Presentation`的布局上。

这里要注意一些调用时序。
 **1. 先关闭正在采集数据的摄像头： `WebRTCHelper.stopSend(1);`**
**2. 创建第二屏的`Presentation`,在`presentation`中重新赋值新的渲染对象并初始化webrtc**

```java
WebRTCHelper.setLocalTextureView(1, mLocalTextureViewSub);
WebRTCHelper.webrtc_init(1,currentCall);
WebRTCHelper.webrtc_startSend(1);
```
此时辅流本段的渲染对象已经切换到Presentation中的TextureView中了，也就实现了本段双屏异显的功能。
#### 4. 关闭本端双屏异显
关闭本端双屏异显，也就是要 关闭那个正在显示的Presentation,这个操作可以像关闭Dialog一样。
另外，还要将辅流本端的渲染对象设置回来。

一步步来。

**1. 销毁正在显示的`Presentation` `mSecondLocalDisplay.cancel()`**
**2. 根据1中设置渲染对象的说法，要先判断我们要设置的渲染对象是否是`available`的**
**3. 如果渲染`textureView`是`available`的，先关闭正在采集数据的摄像头`WebRTCHelper.stopSend(1);`**
**4. 重新将渲染的`TextureView`设置回来。**

```java
WebRTCHelper.setLocalTextureView(1, mLocalTextureViewSub);
WebRTCHelper.webrtc_init(1,currentCall);
WebRTCHelper.webrtc_startSend(1);
```
此时就完成本段辅流双屏异显的关闭。

#### 5. 开启辅流对端双屏异显

因为对端辅流不涉及到摄像头的采集，所以不需要像本端辅流双屏异显时那样还要关闭摄像头。
另外，在辅流对端的`Presentation`中，将渲染对象修改之后
`WebRTCHelper.setRemoteTextureView(1, mRemoteTextureViewSub);`
只需要**暂停接收，再恢复接收**就好，这里要和  `WebRTCHelper.webrtc_stopReceive(1);`区分，**暂停是不释放webrtc通道的。**


```java
WebRTCHelper.webrtc_stopReceiveOnly(1);
WebRTCHelper.webrtc_startReceiveOnly(1);
```
#### 6. 关闭辅流对端双屏异显
注意调用流程

**1. 关闭双屏异显（远端）**
`mSecondDisplay.cancel();`
**2. stopRecvOnly(1) 先暂停接收**
     `WebRTCHelper.webrtc_stopReceiveOnly(1);`
**3. 重新将渲染对象设置回来**
 
```java
WebRTCHelper.setRemoteTextureView(1, mRemoteTextureViewSub);
```
**4. 重新开始接受对端视频数据**
 WebRTCHelper.webrtc_startReceiveOnly(1);

#### 7. 辅流发送与暂停
**1. 要先告知`linphone`底层，先去协商申请发送**
`LinphoneManager.getLc().bfcpFloorRequestSend();`
**2. 当协商成功，通话状态会回调`CallLocalVideo2RequestGranted`**
**3. 在回调中，可以开始发送辅流**

```java
if(state == State.CallLocalVideo2RequestGranted){
                   if(videoCallFragment!=null){
                       videoCallFragment.startSendSubStream();
                   }
               }
```
            
**4. 开始发送辅流 初次发送，要初始化webrtc，并设置辅流渲染对象。**
**5. 后续的暂停 和恢复 都只需要调用`startSendOnly(1)`和`stopSendOnly(1)`**
` WebRTCHelper.webrtc_stopSendOnly(1);`

#### 8. 设置只解码和只编码

**只解码不编码**

```java
MediaEngine.setReceiveVideo(boolean enable);
```
**只编码不解码**

```java
MediaEngine.setSendVideo(boolean send);
```

### 摄像头采集的一些参数调整

开启相机采集数据的代码 在

**VideoCaptureAndroid**

```java
private void startCaptureOnCameraThread(
      int width, int height, int min_mfps, int max_mfps,
      Exchanger<Boolean> result) {
        ···
         Camera.Parameters parameters = camera.getParameters();
      Log.d(TAG, "isVideoStabilizationSupported: " +
          parameters.isVideoStabilizationSupported());
      if (parameters.isVideoStabilizationSupported()) {
        parameters.setVideoStabilization(true);
      }
      parameters.setAntibanding(ANTIBANDING_OFF);
      parameters.setPictureSize(width, height);
      parameters.setPreviewSize(width, height);
      parameters.setAutoExposure(AUTO_EXPOSURE_FRAME_AVG);
      parameters.setExposureCompensation(2);
      // Check if requested fps range is supported by camera,
      // otherwise calculate frame drop ratio.
      List<int[]> supportedFpsRanges = parameters.getSupportedPreviewFpsRange();
      frameDropRatio = Integer.MAX_VALUE;
      for (int i = 0; i < supportedFpsRanges.size(); i++) {
        int[] range = supportedFpsRanges.get(i);
        if (range[Parameters.PREVIEW_FPS_MIN_INDEX] == min_mfps &&
            range[Parameters.PREVIEW_FPS_MAX_INDEX] == max_mfps) {
          frameDropRatio = 1;
          break;
        }
        if (range[Parameters.PREVIEW_FPS_MIN_INDEX] % min_mfps == 0 &&
            range[Parameters.PREVIEW_FPS_MAX_INDEX] % max_mfps == 0) {
          int dropRatio = range[Parameters.PREVIEW_FPS_MAX_INDEX] / max_mfps;
          frameDropRatio = Math.min(dropRatio, frameDropRatio);
        }
      }
```

#### 曝光调整：

```java
parameters.setAutoExposure(AUTO_EXPOSURE_FRAME_AVG);
parameters.setExposureCompensation(2);
```
**测光模式**
有三种取值：点测光、中央重点测光、平均测光，分别取值如下:

```java
        public static final String AUTO_EXPOSURE_CENTER_WEIGHTED = "center-weighted";
        public static final String AUTO_EXPOSURE_FRAME_AVG = "frame-average";
        public static final String AUTO_EXPOSURE_SPOT_METERING = "spot-metering";
```

点测光： 测光取样点很小，虽然可以手动设置测光点位置，但是只对单一区域测光容易导致画面忽明忽暗

平均测光：  对整体画面进行测光，可以避免忽明忽暗的情况，画面亮度均匀

中央重点测光：  以上两者的综合，可以自定义测光矩阵位置和测光矩阵大小，手动设置各测光矩阵的权重值，但是仍然会有明暗切换明显的情况出现，比较考验经验。

**曝光补偿**

```java
parameters.setExposureCompensation(2);
```

手动为系统测量的曝光值人为添加几档，不同平台的可支持范围不一样，最好先获取最大支持范围再设置。

**我们目前选择的方式**

目前采用 平均测光 + 手动增加2档曝光值的方式。

#### 采集画面闪烁

关闭安卓自带的抗闪烁功能

```java
parameters.setAntibanding(ANTIBANDING_OFF);
```
#### 目前还存在的问题：
摄像头最大只支持15fps，需要驱动层修改

# Launcher3 

## 一、仓库和分支说明

```
仓库地址：
http://192.168.26.100/rom/Launcher3

分支说明： 主分支 v101
```

## 二、如何添加自定义图标包
### 1. 创建`icon_replacement.json`文件
文件格式如下：


```json
"useCustomWorkspace":"false",  // 是否使用res/xml/v101/v200_custom_workspace.xml 布局文件
    "icon_rows":"",  // workspace 的图标行数
    "icon_columns":"", // workspace 图标列数
    "numFolderRows":"", // 当将图标在桌面堆叠在一起生成一个小文件夹时  文件夹的图标行数
    "iconSize":"", // 图标尺寸 
    "numHotseatIcons":"", // hotseat 图标数
    "hotseatIconSize":"", // hotseat 图标大小  
     // 注： 以上配置 填空字符串即表示使用默认值
    "iconHide":[   // 图标隐藏字段 需要隐藏的图标 请在iconHide字段中增加对应的包名类名  如果应用只有一个图标 只填写包名即可 如果一个
                         //包名对应多个类名  则包名 类名都需要填写
        {
            "packageName":"com.android.launcher3",
            "className":""
    },       // 图标替换字段  在该字段中填写需要替换的图标 包名 类名的填写逻辑和上面一样 不过还需要填写需要替换的图标文件名称
            // iconName 图标文件名称： 放置在与该json文件同目录下 图标文件名要和iconNama中填写的一致
"iconReplacement": [
        {
            "packageName": "com.android.soundrecorder",
            "className":"",
            "iconName": "icon_record.png"
        },
```

![](/media/15343210186813.png)

###  2. 按照`icon_replacement.json` 文件的`iconHide`字段 在同目录中放置对应的图标文件 图标大小最好大于160*160px
### 3. 将上述文件一起放置在`oem/custom/launcher/` 目录下实现图标替换。
### 4. 具体的格式可以参考项目目录下的`icon1 icon2` 目录
---
## 三、 launcher 项目主要文件说明：
### 1. res/xml 
放置桌面快捷方式布局 热区图标 桌面小部件布局 会根据对应型号 查找对应的布局文件。
查找的逻辑在：`InvariantDeviceProfile.java`中的134行起。
### 2. launcher3/util/IconReplacementUtils.java 
替换图标的代码 

图标优先级为：

* oem/launcher/custom/
* 项目目录 /assets/
* 应用自带图标

### 3.v210_default_workspace_5*6.xml

workspace的布局配置文件：

```xml

<favorites xmlns:launcher="http://schemas.android.com/apk/res-auto/com.android.launcher3">

    <!-- Hotseat -->
    <include launcher:workspace="@xml/v210_tablet_hotseat_ipdmthj" /> 
   <!-- 小部件 -->
   <appwidget
        launcher:packageName="com.telpo.weather" //包名 
        launcher:className="com.telpo.weather.receiver.widget.WidgetClockDayProvider" //类名
        launcher:screen="0" //第几屏 最大有5屏 默认主页是第0屏 
        launcher:x="0" // 左上角坐标 如果是7*4 workSpace 占 7*3  7*1 被hotSeat占据 左上角为（0,0） 右下角是（6,2）
        launcher:y="0"
        launcher:spanX="3" // 占据位置大小
        launcher:spanY="1"/>
  <resolve
        launcher:container="-101" // 表示为hotSeat 按钮
        launcher:screen="4" //hotSeat按钮位置
        launcher:x="4" //hotSeat按钮坐标 
        launcher:y="0" >
        <favorite
            launcher:packageName="com.neotel.livephonev"
            launcher:className="com.neotel.livephonev.Activity.LoginActivity"
            launcher:container="-101"
            />

    </resolve>
```

## 四、 日后可能遇到的扩展需求：
1. 隐藏某些app图标:
2. 替换某些app图标

问题1 直接修改asset目录下的`icon_replacement.json`文件 在`icon_hide`字段增加对应的包名类名就好了。
问题2 同问题1 修改`asset`目录下的`icon_replacement.json`文件，在`iconReplacement`字段增加新的包名类名，然后在根目录添加对应的图标文件。注意文件名要一致才可以替换成功。

## 五、 编译注意事项：
launcher项目可以直接在AndroidStudio编译
但是只可以编译**user_debug**版本，因为**release**版本会因为一些字符串的问题被androidStudio的lint报错，修改起来是个大工程，**user_debug**版本不会影响使用。如果需要签名 可以使用

```
signapk.jar
platform.pk8
platform.x509.pem 
```
系统签名秘钥去执行签名。

```bash
Java -jar signapk.jar platform.x509.pem platform.pk8 Launcher3.apk  C:\Users\jiangxq170307\Desktop\Launcher3.apk
```
对应文件在交接书目录中。
## 六、 一次完整的编译、调试、推送流程演示。

下面展示一下 launcher3项目一次完成的编译，打包，签名，测试，推送到仓库的流程。比如要将当前v101桌面默认布局中的设置图标删除。

### 修改代码并编译apk

在androidStudio修改对应配置workspace文件
![](/media/15344756086699.jpg)

打包debug版本apk
![](/media/15344751475800.jpg)
![](/media/15344751512603.jpg)


### 手动进行签名
拷贝打包出来的apk，手动签名
![](/media/15344751586998.jpg)

### 调试看修改是否生效
将apk推送到设备对应目录，清空缓存，查看修改是否生效

推送apk
![](/media/15344751680206.jpg)

清空缓存
![](/media/15344751949880.jpg)

重启zygote进程

![](/media/15344752077752.jpg)

查看是否修改成功

### 推送apk到远端

当确认无误，将apk拷贝到**vendor_telpo_prebuild_common**仓库的
`/overide/Launcher/TelpoLauncher3.apk ` 目录 推送到远程仓库中。
![](/media/15344752363043.jpg)



